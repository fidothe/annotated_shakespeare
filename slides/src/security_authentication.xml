<?dbhtml pygments="true"?>
<slides xml:lang="en" xmlns="http://docbook.org/ns/docbook"
  xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink">
  <info>
    <title>Practical Web Applications</title>
    <subtitle>Security and Authentication</subtitle>
    <!-- authors are alphabetical by first name (I get sick of being listed last all the time, 
so I always do this if I can) -->
    <authorgroup>
      <author>
        <personname>
          <firstname>Lauren</firstname>
          <surname>Wood</surname>
        </personname>
        <affiliation>
          <orgname>Textuality Services, Inc.</orgname>
        </affiliation>
      </author>
      <author>
        <personname>
          <firstname>Matt</firstname>
          <surname>Patterson</surname>
        </personname>
        <affiliation>
          <orgname>Constituent Parts, Ltd.</orgname>
        </affiliation>
      </author>
      <author>
        <personname>
          <firstname>Norman </firstname>
          <surname>Walsh</surname>
        </personname>
        <affiliation>
          <orgname>MarkLogic</orgname>
        </affiliation>
      </author>
      <author>
        <personname>
          <firstname>Paul</firstname>
          <surname>Downey</surname>
        </personname>
        <affiliation>
          <orgname>Whatfettle</orgname>
        </affiliation>
      </author>
    </authorgroup>
    <releaseinfo role="version">Version 1.0</releaseinfo>
    <legalnotice>
      <para>Alpha by first name</para>
    </legalnotice>
    <pubdate>2012-09-20</pubdate>
    <copyright>
      <year>2012</year>
      <holder>Lauren Wood, Matt Patterson, Norm Walsh, Paul Downey</holder>
    </copyright>
  </info>
  <foilgroup>
    <title>Identity Concepts</title>
    <foil>
      <title>Facets of Identity</title>
      <itemizedlist>
        <listitem>
          <para>Who am I today? Or now?</para>
        </listitem>
        <listitem>
          <para>Role I’m playing right now </para>
        </listitem>
        <listitem>
          <para>Identity depends on what I’m doing </para>
        </listitem>
        <listitem>
          <para>Anonymous vs pseudonymous vs Real Names</para>
        </listitem>
      </itemizedlist>
      <speakernotes>
        <para>Identity: the overarching “who am I” – or rather, what persona am I using for this
          purpose? Identity is multi-faceted – checking my personal mail, or auditing the financial
          records for a large corporation are manifestations of different identities, even if I’m
          the same person carrying out both activities. I may have to use a real name for some
          activities, for others I can use a pseudonym, for others I can use a one-off “handle” or
          no label at all. </para>
      </speakernotes>
    </foil>
    <foil>
      <title>Authentication</title>
      <para>Am I talking to the person I think I’m talking to? </para>
      <para>Is it the person, or someone using their computer? </para>
      <para>How sure do I have to be that it’s the right person? </para>
      <para>Levels of identification and authentication depend on application. </para>
      <para>“Something you are, something you have, something you know” </para>
      <para>Identity verification (proofing) - digital version of notaries?</para>
      <speakernotes>
        <para>who am I really talking to? Note the associated issues of is it really the person, or
          is it someone using that person’s credentials? In real life we have notaries who will
          check your identification and assert as a trusted third party that it was really you; in
          the digital arena we don’t have anything with the same level of guarantee. The trinity of
          “something you have (e.g., token, card), something you know (e.g., password), something
          you are (e.g., biometric)” helps, as each separate item requires a separate check of the
          authentication. Identity verification is separate to authentication. Also called identity
          proofing. This is mapping a digitally-used identity back to a real person. Every time the
          person shows up with the digital id, want to prove they do go back to the real person. US
          gov tries to add trust, chain of custody that’s strong enough to go back to the real world
          – can you make the proof strong enough if someone did something wrong etc. </para>
      </speakernotes>
    </foil>
    <foil>
      <title>Authorisation</title>
      <para>Is this person allowed to do what they want to do? </para>
      <itemizedlist>
        <listitem>
          <para>as an individual </para>
        </listitem>
        <listitem>
          <para>as a member of a group </para>
          <para>static name list of all allowed to do “X”</para>
        </listitem>
        <listitem>
          <para>with a particular role </para>
          <para>assign role to person; everyone with that role allowed to do “Y”</para>
        </listitem>
      </itemizedlist>
      <speakernotes>
        <para>Typically used in enterprises; the big problem is trying to minimise the number of
          roles so you don’t have each person having their own role! Groups are static, but a good
          first step to figuring out the roles.</para>
      </speakernotes>
    </foil>
    <foil>
      <title>And the rest</title>
      <para>Confidentiality</para>
      <itemizedlist>
        <listitem>
          <para>only the right people can see this</para>
        </listitem>
      </itemizedlist>
      <para>Auditing </para>
      <itemizedlist>
        <listitem>
          <para>track who accessed the system and what they did </para>
        </listitem>
      </itemizedlist>
      <para>Integrity</para>
      <itemizedlist>
        <listitem>
          <para>did the information arrive whole and untouched?</para>
        </listitem>
      </itemizedlist>
    </foil>
    <foil>
      <title>Trust and other nebulous aspects</title>
      <para>Technical aspects </para>
      <itemizedlist>
        <listitem>
          <para>exchange public keys and metadata </para>
        </listitem>
      </itemizedlist>
      <para>Legal level </para>
      <itemizedlist>
        <listitem>
          <para>contracts, agreements </para>
        </listitem>
      </itemizedlist>
      <para>Policy</para>
      <itemizedlist>
        <listitem>
          <para>what are the conditions for our working together?</para>
        </listitem>
      </itemizedlist>
      <para>Non-repudiation</para>
      <itemizedlist>
        <listitem>
          <para>how do we make orders irrevocable?</para>
        </listitem>
      </itemizedlist>
      <speakernotes>
        <para>trust (how do I know I can trust you or your system?), policy (have we actually agreed
          that we can work together?), and non-repudiation (so they can’t claim afterwards it wasn’t
          them sending the request). Non-repudiation needs a high level of assurance that the
          authentication is accurate, and depends on the integrity of the data to make sure fake
          data wasn’t sent or received. </para>
      </speakernotes>
    </foil>
    <foil>
      <title>Summary</title>
      <informaltable border="1" cellpadding="1">
        <tr>
          <th>Requirement</th>
          <th>Technologies</th>
        </tr>
        <tr>
          <td>Authentication</td>
          <td> Username/password, key-based digital signing, challenge-response, biometrics, smart
            cards </td>
        </tr>
        <tr>
          <td>Authorisation</td>
          <td> Policy engines, directory attributes, access control, digital rights management,
            active directory </td>
        </tr>
        <tr>
          <td>Auditing</td>
          <td> Secure logging + analysis </td>
        </tr>
        <tr>
          <td>Integrity</td>
          <td> Message digest, authenticated with a digital signature </td>
        </tr>
        <tr>
          <td>Confidentiality</td>
          <td> Key-based digital encryption and decryption </td>
        </tr>
        <tr>
          <td>Non-repudiation</td>
          <td> Key-based digital signing and signature verification, message reliability,
            legal/contractual agreements </td>
        </tr>
        <tr>
          <td>Trust</td>
          <td>Setting up parameters for all the above </td>
        </tr>
      </informaltable>
    </foil>
  </foilgroup>
  <foilgroup>
    <title>HTTP-based authentication</title>
    <foil>
      <title>HTTP Basic authentication</title>
      <para>Basic authentication - HTTP 1.0, 1999, RFC 2617</para>
      <itemizedlist>
        <listitem>
          <para>widely implemented </para>
        </listitem>
        <listitem>
          <para>not secure, password sent in clear text </para>
        </listitem>
        <listitem>
          <para>protects resources in authentication realm </para>
        </listitem>
      </itemizedlist>
      <mediaobject role="center">
        <alt>application architecture components</alt>
        <imageobject>
          <imagedata fileref="../images/httpbasicauth.svg"/>
        </imageobject>
      </mediaobject>
      <speakernotes>
        <para> isn’t particularly secure, but it is easy to implement. The page(s) that require the
          password are said to be in an authentication realm, which is usually all the pages in a
          particular directory on the web site. When the browser asks to be shown one of those
          pages, the HTTP server responds with a 401 code (Unauthorized) and typically the name of
          the authentication realm. The browser typically then puts up a dialog box, asking for the
          username and password. The credentials are concatenated, base64-encoded (for ease of
          handling, not security), and sent to the server. If the credentials are accepted, the
          server sends the page back to the browser for display. The big security hole with this one
          is that the username and password are sent as plain text (base-64 encoding doesn’t add any
          security as it’s trivial to decode the string). If you use SSL or some other method to
          secure the channel (the way the information is sent from point A to point B), then this is
          ok. If you don’t, then someone sitting in between the two end-points could pick up the
          information. </para>
      </speakernotes>
    </foil>
    <foil>
      <title>HTTP Digest authentication</title>
      <itemizedlist>
        <listitem>
          <para>Encrypts the password using cryptographic hash aka digest</para>
        </listitem>
        <listitem>
          <para>Cryptographic hash is effectively impossible to break</para>
        </listitem>
        <listitem>
          <para>Quick to compute the digest from the string</para>
        </listitem>
        <listitem>
          <para>Security further improved by using a nonce (random number, generated on server, that
            changes each time the client gets the 401)</para>
        </listitem>
        <listitem>
          <para>Easier to implement/use HTTP Basic over SSL/TLS than HTTP Digest</para>
        </listitem>
      </itemizedlist>
      <speakernotes>
        <para>encrypts the password using a cryptographic hash system. A cryptographic hash function
          is a procedure that takes some data (the message) and gives you back a fixed-size string,
          called a cryptographic hash, message digest, or digest (hence the name of HTTP Digest).
          The idea of the cryptographic hash is that it’s incredibly hard to create a message with a
          given digest, it’s incredibly hard to modify a message without changing the digest, and
          it’s incredibly hard to find two messages that have the same digest. “Incredibly hard” is
          often called “infeasible”, or “effectively impossible”. So if you store (or pass) your
          password in digest form, it should be effectively impossible to break the digest to figure
          out the password. But it’s quick to compute the digest for a password the user inputs, and
          compare that to the stored digest. HTTP Digest uses a standard cryptographic hash
          function, called MD5, which generates a 32-digit hexadecimal number. It’s not perfect and
          in fact was considered to be broken in 2004-5, but it is still widely used outside of
          government applications. The security can be improved by using a “nonce” (number used
          once), which is a random number generated on the server that is changed each time the
          client receives that 401 code we discussed previously. So now the client has to take the
          username, the authentication realm name, the password, and the nonce, and create the MD5
          hash of all of that information to send to the server. This is more secure than the plain
          text version! And for additional security, the client may also generate a nonce, hashing
          it with all the other information. As always, there are more details and I’ve skimmed over
          most of the finer points. And in practice, most sites use HTTP Basic over SSL/TLS rather
          than implementing HTTP Digest. </para>
      </speakernotes>
    </foil>
    <foil>
      <title>Summary: HTTP authentication</title>
      <para>Based on password authentication </para>
      <itemizedlist>
        <listitem>
          <para>weak authentication (only one factor) </para>
        </listitem>
        <listitem>
          <para>people tend to forget their passwords </para>
        </listitem>
        <listitem>
          <para>solutions to forgetting often not secure </para>
        </listitem>
        <listitem>
          <para>easy to implement </para>
        </listitem>
        <listitem>
          <para>suitable for “don’t need much protection” resources </para>
        </listitem>
        <listitem>
          <para>Digest more secure but harder to use </para>
        </listitem>
        <listitem>
          <para>Use Basic over SSL for reasonable security</para>
        </listitem>
        <listitem>
          <para>Encrypt your passwords in storage</para>
        </listitem>
      </itemizedlist>
    </foil>
  </foilgroup>
  <foilgroup>
    <title>Outsourcing identity</title>
    <foil>
      <title>Why?</title>
      <para>Best principle for keeping user data around:</para>
      <para role="center"><emphasis>DON’T</emphasis></para>
      <itemizedlist>
        <listitem>
          <para>Treat PII as radioactive, keep as little as possible.</para>
        </listitem>
        <listitem>
          <para>Push responsibility (and support costs for lost passwords) onto someone else.</para>
        </listitem>
        <listitem>
          <para>They might even implement higher security (two or three-factor
            authentication).</para>
        </listitem>
        <listitem>
          <para>Your users may use Google/Twitter/Facebook anyway.</para>
        </listitem>
      </itemizedlist>
      <para>But...</para>
      <itemizedlist>
        <listitem>
          <para>what happens if that company closes down?</para>
        </listitem>
        <listitem>
          <para>what happens if that company misuses the information?</para>
        </listitem>
        <listitem>
          <para>what happens if that company changes its terms of use?</para>
        </listitem>
      </itemizedlist>
      <speakernotes>
        <para>If you’re creating a web-based application, or web site that has users you want to be
          able to identify or disambiguate in some way (whether or not you require real names or
          anything that looks like a real name), the standard rule is to treat all personally
          identifiable information as if it were radioactive. I.e., keep as little as possible for
          as short a time as possible. Depending on what your application does, or who your probable
          users are, it might be a good idea to “outsource” your authentication by asking the user
          to sign in with Twitter, or Facebook, or a Google account. This can have its downsides –
          can I be sure that Twitter won’t somehow misuse the information? What happens when/if
          they’re bought or close down? In the meantime, however, it’s not a bad model and saves
          having to handle those lost password queries. </para>
        <para>company may also change TOC and not let you access its user database any more, e.g.,
          twitter if you have too many users.</para>
      </speakernotes>
    </foil>
    <foil>
      <title>Sign in with...</title>
      <informaltable border="1" cellpadding="1">
        <tr>
          <th>Specification</th>
          <th>Who uses it</th>
          <th>Notes</th>
        </tr>
        <tr>
          <td>OAuth 1</td>
          <td>Twitter, LinkedIn.</td>
          <td>Incompatible with, and (theoretically) obsoleted by, OAuth 2. </td>
        </tr>
        <tr>
          <td>OAuth 2</td>
          <td>Facebook, github, Salesforce, lots of others</td>
          <td>Became an RFC in July 2012. Designed for authorising access to resources, rather than
            for outsourcing authentication, but widely used for authentication, e.g., <link
              xlink:href="https://developers.facebook.com/docs/authentication">Facebook</link>.
          </td>
        </tr>
        <tr>
          <td>OpenID</td>
          <td>Google, Paypal as IdPs, many websites accept it for sign-in</td>
          <td> The user can register at any provider (including their own website), then use that
            login to log in at any site that accepts those registrations. UI issues make it
            inconvenient. Original use case was for blog comments to prevent spam; original design
            had security issues. Some of these security issues were fixed in OpenID 2, which Google
            and Paypal support. </td>
        </tr>
        <tr>
          <td>Persona (was browserID)</td>
          <td>Mozilla (persona.org)</td>
          <td>Uses user's email address (provided by a primary identity authority) to authenticate
            to a third-party identity provider (called an implementation provider, or secondary
            identity authority). This may be in the web browser (e.g., Firefox) or server
            (persona.org). Not widely implemented, some confusion with OpenID, some security
            issues.</td>
        </tr>
      </informaltable>
      <speakernotes>
        <para>Twitter uses OAuth as the protocol. Facebook uses OAuth 2. Mozilla started Persona
          (browserID), but this is not taking off all that fast and doesn't seem to work for mobile
          apps. Google mail (for example) should be able to support it as a primary identity
          authority, but I haven't found it documented anywhere that it actually does. We're going
          to use it in our app, but more because it's easy than because it's better.</para>
        <para>Some other services use OpenID. Like OAuth, OpenID uses the standard HTTP
          request-response mechanism to ask for authentication. The user can register at any
          provider, then use that login to log in at any site that accepts those registrations. The
          original use case was to provide some sort of way to allow blog comments from people and
          cut down on the spam. The user just has to remember one username/password and can log in
          at multiple places. And you don’t need to trust that shiny new site with any personal
          information (other than your username and which OP you use) that you have stored at your
          OpenID Provider, you can decide yourself how much information to let it have.
          Persona/browserID is similar, but uses an email address rather than a URL for
          identification.</para>
        <para>The IdP is the authoritative source for information about the user, not just the place
          where the user stores some resource. In a sense, we now want to use the service provider
          as a source of metadata, not just data (if you think of info about the user as being
          metadata, and what they have there is the data). E.g., Twitter stores your name, your
          email, the city you live in, and a description that you supply. An application can use
          some of that and theoretically doesn’t need to store it itself. Google allows this through
          the OpenID attribute exchange protocol.</para>
      </speakernotes>
    </foil>
    <foil>
      <title>The "classic" roles</title>
      <mediaobject role="center">
        <alt>Roles - identity provider, relying party, user</alt>
        <imageobject>
          <imagedata fileref="../images/three_identity_roles.svg"/>
        </imageobject>
      </mediaobject>
      <para>In these flows, there are three roles (parties) - the identity provider, the relying
        party, and the user.</para>
      <para>Tokens (credentials) are exchanged between the actors representing either the actor or
        the authentication/authorisation.</para>
      <speakernotes>
        <para>These credentials (such as username and password, or public/private key pair) may be
          encrypted or signed, depending on the protocol, or it may be expected that all information
          is passed via TLS/SSL. There are a number of different systems for this; I'll introduce a
          couple of them, and then we'll add one to our application. </para>
      </speakernotes>
    </foil>
    <foil>
      <title>More roles</title>
      <para>Role proliferation</para>
      <mediaobject>
        <alt>More roles</alt>
        <imageobject role="center">
          <imagedata fileref="../images/more_identity_roles.svg"/>
        </imageobject>
      </mediaobject>
      <speakernotes>
        <para>The top four are for OAuth 2, the bottom three are for browserID. Note the different
          names for each. The flows aren't shown here, as basically everything talks to everything
          at some stage, passing tokens back and forth, so it gets complicated. More details as we
          get to them. BrowserID is up next, then OAuth 2.</para>
      </speakernotes>
    </foil>
    <foil>
      <title>BrowserID roles</title>
      <mediaobject>
        <alt>BrowserID roles</alt>
        <imageobject role="center">
          <imagedata fileref="../images/browseridroles.svg"/>
        </imageobject>
      </mediaobject>
      <speakernotes>
        <para>Primary Identity Authorities (primary) - Services that directly provide the user with
          an identity in the form of an email address. Example primaries include Yahoo! mail or
          gmail, except they don't support this.</para>
        <para>Implementation Provider (or IP) - This may be the user's web browser if native support
          for BrowserID exists, otherwise browserid.org or login.persona.org. These implement the
          client portion of the system. In addition to key management and implementation, the IP
          also serves as a Secondary Identity Authority. </para>
        <para>The system has some security concerns, we'll talk more about that in the next phase.
          it's implemented with JavaScript and relies on cross-document messaging, an API defined in
          HTML 5.</para>
      </speakernotes>
    </foil>
    <foil>
      <title>OAuth 2 roles</title>
      <mediaobject>
        <alt>BrowserID roles</alt>
        <imageobject role="center">
          <imagedata fileref="../images/oauth2roles.svg"/>
        </imageobject>
      </mediaobject>
      <speakernotes>
        <para>OAuth 2 wasn't designed for authentication, but rather for authorisation. </para>
      </speakernotes>
    </foil>
  </foilgroup>
  <foilgroup>
    <title>Web security basics</title>
    <subtitle>Connection-based security, message-based security, and some relevant
      standards</subtitle>
    <foil>
      <title>Connection-based security</title>
      <para>Secures the path between two end-points. </para>
      <para>Security is transient, only for the data in motion. </para>
      <para>Relatively simple to use, high performance. </para>
      <para>Point to point solution, doesn’t work across middle points.</para>
      <speakernotes>
        <para>Connection based security (like SSL) just secures the path between two endpoints. The
          security is transient in that it’s only active while a message is being transferred. Once
          a message is received it’s no longer encrypted. The advantage is that you can use this
          type of security for lots of different types of messages, it’s relatively high
          performance, and simple to use. The disadvantage is that you have to figure out how to
          secure the information (if it needs to be secured) once it’s arrived, and you can’t pass
          on the secure message as is, complete with its encryption. connection security as name is
          better than channel or transport. Protecting data in motion vs at rest.</para>
      </speakernotes>
    </foil>
    <foil>
      <title>HTTPS/TLS/SSL</title>
      <para>Adds encryption, signing, records, and session tracking to the basic HTTP </para>
      <orderedlist>
        <listitem>
          <para>browser sends request to port 443 with session ID, encryption algorithms it likes,
            random string, and requested website </para>
        </listitem>
        <listitem>
          <para>web site sends back server name, session ID, encryption algorithm, server version of
            the string, and server certificate </para>
        </listitem>
        <listitem>
          <para>browser decides whether to trust the certificate, checks the host name </para>
        </listitem>
        <listitem>
          <para>exchange tokens (secrets) to encrypt the data </para>
        </listitem>
        <listitem>
          <para>start exchanging encrypted data with session IDs and sequence numbers</para>
        </listitem>
      </orderedlist>
      <speakernotes>
        <para>This is often called SSL/TLS. SSL (Secure Sockets Layer) was the first name, and it
          was developed by Netscape. Eventually the IETF took over, and released a new version in
          1999, renamed Transport Layer Security (TLS). TLS is a record-based request-response
          format, with records of different types depending on where you are in the session. Instead
          of sending the request message as is to port 80 on a web server as for HTTP, the browser
          (client) kicks off the TLS session by sending a handshake to port 443. This is the
          handshake record, saying what time it is, which session ID (if any) this session ID has,
          which encryption algorithms the client supports (in order of preference), and which
          website the client is trying to reach (for the case that the IP address given supports
          multiple websites). It also includes 28 random bytes (we’ll get to those later). The web
          site responds, and let’s assume agrees with the requests, so the server sends back the
          server time, a session ID, and the encryption algorithm it will use, along with a server
          version of the 28 random bytes. It also sends the SSL Server Certificate, the basis of the
          trust system. Then the client decides whether (or not) to trust the certificate. The
          certificate is signed by a Certification authority (a company such as Verisign) using
          their private key. The client (browser) has a list of Certification authorities that it
          trusts, and that’s the basis of the trust that you put in the little lock sign on your
          browser. Once the client decides to approve that certificate, it checks whether the host
          name you sent the request to is the same as the name listed in the certificate. This is to
          prevent man-in-the-middle attacks, where someone sitting in between your client and the
          server you’re trying to reach can forge credentials. With the Certification authority
          signing the certificate, you can trust that the certificate is real (well, assuming you
          can trust that Certification authority). You can also add certificates that you trust
          yourself (hopefully for good reason!) to your list. </para>
        <para>http://www.moserware.com/2009/06/first-few-milliseconds-of-https.html</para>
        <para>OK, so we’re sure that we’ve reached the server and web site we wanted, and know which
          encryption algorithm they’ll use. We even have a session ID so we can avoid the handshake
          step for the rest of our session at that site. The client sends what’s called a
          “pre-master secret” to the server, a value that’s meant to be random and secret. Getting
          this value to be effectively random is hard and a number of implementers have discovered
          this the hard way, introducing security holes that were exploited. The pre-master secret
          should only be used for this one session as well. Then the client encrypts a padded
          version of the pre-master secret, and sends that to the server. The server calculates the
          master secret from the pre-master secret and the two random 28-byte values that the client
          and the server exchanged in the first handshake. These two secrets are used to derive all
          the session keys that are used to encrypt the actual HTTP request-response messages. There
          is also a sequence number, so that an attacked can’t simply copy one of the messages,
          change it, and resend (this is called a “replay” attack). The HTTP system acts as normal,
          and doesn’t need to worry about the encryption. It’s the TLS layer underneath that does
          all the work. The connection is closed when one side sends “closure alert” message. One
          point – you can use the same TLS system for other protocols, such as FTP, since it does
          sit underneath the protocol layer, but for this course we’re mostly interested in the
          HTTPS usage. </para>
      </speakernotes>
    </foil>
    <foil>
      <title>What is a Certificate?</title>
      <itemizedlist>
        <listitem>
          <para>Electronic document, typically in X.509 format</para>
        </listitem>
        <listitem>
          <para>Used in PKI (public key infrastructure) systems</para>
        </listitem>
        <listitem>
          <para>Includes a public key</para>
        </listitem>
        <listitem>
          <para>Includes identity information for person or corporation</para>
        </listitem>
        <listitem>
          <para>Includes hostname if intended to be used for TLS</para>
        </listitem>
        <listitem>
          <para>Digitally signed</para>
        </listitem>
        <listitem>
          <para>Signature attests that identity information and public key belong together</para>
        </listitem>
        <listitem>
          <para>Signature usually comes from a Certification Authority </para>
        </listitem>
      </itemizedlist>
      <speakernotes>
        <para>The certificate also commonly includes a serial number, algorithm used to create the
          digital signature, validity dates (from and to), the algorithm used to hash the
          certificate, the hash itself that proves the certificate has not been tampered with, and
          the purpose of the public key. Verisign (one of the big Certificate Authorities) has a
          number of classes of certificates, ranging from those used by individuals, to
          organizations, servers (these ones require independent verification), online business
          transactions, and governments. The EU has its own set of requirements for certificates,
          which are similar in concept. </para>
        <para>There are a number of issues with certificates, which I’m not going to go into here.
          Wikipedia has links to get you started.</para>
      </speakernotes>
    </foil>
    <foil>
      <title>Certificate Authorities</title>
      <para>An aside on certificate authorities </para>
      <itemizedlist>
        <listitem>
          <para>ultimate source of the trust in the system</para>
        </listitem>
        <listitem>
          <para>the authority signs the certificate</para>
        </listitem>
        <listitem>
          <para> what happens if the authority is hacked?</para>
        </listitem>
        <listitem>
          <para>what happens if the certificate authority is not trustworthy?</para>
        </listitem>
      </itemizedlist>
      <speakernotes>
        <para>While we’re on the subject, certificates can be revoked. When this happens, you should
          delete them from your “trusted” list. Unfortunately, few people know about this and even
          fewer check their certificates regularly to see if they have been revoked!</para>
        <para>Once the client decides to approve that certificate, it checks whether the host name
          you sent the request to is the same as the name listed in the certificate. This is to
          prevent man-in-the-middle attacks, where someone sitting in between your client and the
          server you’re trying to reach can forge credentials. With the Certification authority
          signing the certificate, you can trust that the certificate is real (well, assuming you
          can trust that Certification authority). You can also add certificates that you trust
          yourself (hopefully for good reason!) to your list.</para>
        <para>The main problem with certificates is that it’s turtles all the way up (or down). The
          certificate is signed by someone whose authority is attested to by another certificate,
          etc. Eventually you get to the top level, and there is a set of certificates that are
          built in as being fully trusted. These are usually issued by governments or organizations
          trusted by governments, or trusted by the browser or operating system manufacturer. In the
          DigiNotar case, they were sloppy and were hacked. Even though they were trusted by the
          Dutch government. The only solution is to completely distrust any certificates signed by
          them, as they may not actually have been signed by DigiNotar, but by the hacker.</para>
        <para>And there are alleged to be some certificate authorities in autocratic countries that
          are proxy-in-the-middle points, capable of passing on information to their governments.
          The solution to this is for the browser to not trust those authorities - but they have to
          know who they are first (some are known).</para>
      </speakernotes>
    </foil>
    <foil>
      <title>Message-based security</title>
      <para>Ties the security to the message</para>
      <itemizedlist>
        <listitem>
          <para>protects the data at rest</para>
        </listitem>
        <listitem>
          <para>remains secure once it’s received</para>
        </listitem>
        <listitem>
          <para>can use intermediaries who can’t read it</para>
        </listitem>
        <listitem>
          <para>tied to a particular format</para>
        </listitem>
        <listitem>
          <para>computationally expensive</para>
        </listitem>
        <listitem>
          <para>difficult to implement and use</para>
        </listitem>
      </itemizedlist>
      <speakernotes>
        <para>Message based security ties the security to the actual message so it remains secure
          even once it’s been received (we’re ignoring some security accelerators that strip out the
          security on the way for performance reasons). The security is persistent so that you can
          store the message (or part of the message; you don’t need to encrypt the whole thing) in
          its secured form and still see who signed it two years later. You can also implement a
          system where the message is sent via intermediaries, knowing they can’t read it. The
          disadvantage of message-based security is that it is typically tied to a particular
          message format (such as SOAP+WS-Security or S/MIME), is computationally expensive and
          often relatively complex to implement and use. It’s especially complicated if you want
          long-running message conversations, where you need to figure out how to correlate the
          messages. </para>
      </speakernotes>
    </foil>
  </foilgroup>
  <foilgroup>
    <title>Securing Web Applications</title>
    <subtitle>Important threats and how to guard against them</subtitle>
    <foil>
      <title>OWASP Top Ten</title>
      <para>List of the top ten attacks, how they work, how to prevent them. We’ll concentrate on
        three important attacks: </para>
      <itemizedlist>
        <listitem>
          <para>SQL Injection </para>
        </listitem>
        <listitem>
          <para>Cross-Site Scripting (XSS) </para>
        </listitem>
        <listitem>
          <para>Cross-Site Request Forgery (CSRF)</para>
        </listitem>
      </itemizedlist>
    </foil>
    <foil>
      <title>SQL Injection</title>
      <mediaobject role="center">
        <alt>Little Bobby Drop Table</alt>
        <imageobject>
          <imagedata fileref="../images/xkcd327.png"/>
        </imageobject>
        <caption><para>http://xkcd.com/327/</para></caption>
      </mediaobject>
      <speakernotes>
        <para>Injection attacks, including SQL injection attacks. The attacker manages to send some
          data to the system that is malicious and the system acts on that data. Any part of the
          system can be attacked, so there are attacks using SQL queries, XPath or XQuery, or plain
          XML. The injection can add unwanted data to a database, including giving the attacker
          administrator privileges on your system. One way in which this can occur is when the
          server trusts information from a form, or a query string on a URL. The attacker simply
          adds some data to the form that changes the meaning of the query. E.g., the standard SQL
          injection attack: </para>
      </speakernotes>
    </foil>
    <foil>
      <title>Example code</title>
      <programlisting role="other" language="SQL">
         

      <phrase role="kw">String</phrase> <varname>query</varname> = 
        "<phrase role="kw">SELECT</phrase> * <phrase role="kw">FROM</phrase>
        <varname>accounts</varname> <phrase role="kw">WHERE</phrase>
        <varname>custID</varname> = '" + request.getParameter("id") +"'";

    </programlisting>
      <para>The attacker changes the query URL to http://example.com/app/accountView?id=' or '1'='1
        which leads to the complete query being</para>
      <programlisting role="other" language="SQL">
      <phrase role="kw">SELECT</phrase> * <phrase role="kw">FROM</phrase>
        <varname>accounts</varname> <phrase role="kw">WHERE</phrase>
        <varname>custID ='' or  '1'='1'</varname>
    </programlisting>
      <para>'1'='1' is always true, so the query returns the entire account list.</para>
    </foil>
  </foilgroup>
  <foil>
    <title>OWASP Top Ten</title>
    <mediaobject role="center">
      <alt>application architecture components</alt>
      <imageobject>
        <imagedata fileref="../images/httpbasicauth.svg"/>
      </imageobject>
    </mediaobject>
    <itemizedlist>
      <listitem>
        <para/>
      </listitem>
      <listitem>
        <para/>
      </listitem>
      <listitem>
        <para/>
      </listitem>
      <listitem>
        <para/>
      </listitem>
      <listitem>
        <para/>
      </listitem>
    </itemizedlist>
  </foil>
</slides>
