<?dbhtml pygments="true"?>
<slides xml:lang="en" xmlns="http://docbook.org/ns/docbook"
  xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink">
  <info>
    <title>Practical Web Applications</title>
    <subtitle>Session Four</subtitle>
    <!-- authors are alphabetical by first name (I get sick of being listed last all the time, 
so I always do this if I can) -->
    <authorgroup>
      <author>
        <personname>
          <firstname>Lauren</firstname>
          <surname>Wood</surname>
        </personname>
        <affiliation>
          <orgname>Textuality Services, Inc.</orgname>
        </affiliation>
      </author>
      <author>
        <personname>
          <firstname>Matt</firstname>
          <surname>Patterson</surname>
        </personname>
        <affiliation>
          <orgname>Constituent Parts, Ltd.</orgname>
        </affiliation>
      </author>
      <author>
        <personname>
          <firstname>Norman </firstname>
          <surname>Walsh</surname>
        </personname>
        <affiliation>
          <orgname>MarkLogic</orgname>
        </affiliation>
      </author>
      <author>
        <personname>
          <firstname>Paul</firstname>
          <surname>Downey</surname>
        </personname>
        <affiliation>
          <orgname>Whatfettle</orgname>
        </affiliation>
      </author>
    </authorgroup>
    <releaseinfo role="version">Version 1.0</releaseinfo>
    <legalnotice>
      <para>Alpha by first name</para>
    </legalnotice>
    <pubdate>2012-09-20</pubdate>
    <copyright>
      <year>2012</year>
      <holder>Lauren Wood, Matt Patterson, Norm Walsh, Paul Downey</holder>
    </copyright>
  </info>
  <foilgroup>
    <title>What do we need in order to allow people to comment on an Act?</title>
    <foil>
      <title>An idea of what goes into a Comment</title>
    </foil>
    <foil>
      <title>A way of storing the Comment</title>
    </foil>
    <foil>
      <title>A way of getting a Comment back</title>
    </foil>
  </foilgroup>
  <foilgroup>
    <title>Modelling comments</title>
    <foil>
      <title>Intrinsic features</title>
    </foil>
    <foil>
      <title>Relationships</title>
    </foil>
  </foilgroup>
  <foilgroup>
    <title>Introducing DataMapper</title>
    <foil>
      <title>Object persistence patterns</title>
      <para>Data persistence used to mean constructing SQL queries by hand and 
        executing <code>SELECT</code>, <code>INSERT</code>, or <code>UPDATE</code>
        queries directly from your web app controller.</para>
      <para>More recently, persistence patterns which remove the responsibility
        for writing SQL have emerged.</para>
      <para>Martin Fowler covered several of these in his book <citation>Patterns of Enterprise Application Architecture</citation>.</para>
      <para>Two of those, <emphasis>Active Record</emphasis> and <emphasis>Data Mapper</emphasis> have come to dominate.</para>
    </foil>
    <foil>
      <title>Active Record</title>
      <para>An object that wraps a row in a database table or view, encapsulates the database access, and adds domain logic on that data.</para>
      <speakernotes>
        <para>PoEAA p160</para>
        <para>The high level summary: An object which knows how to save, retrieve, and find itself in the DB. Requires that the DB and object schemas are in lockstep. The Rails' framework's ActiveRecord library is perhaps the best known implementation.</para>
      </speakernotes>
    </foil>
    <foil>
      <title>Data Mapper</title>
      <para>A layer of Mappers that moves data between objects and a database while keeping them independent of each other and the mapper itself.</para>
      <para>Mapper: An object that sets up a communication between two independent objects</para>
      <speakernotes>
        <para>PoEAA p165, p473</para>
        <para>The high level summary: More abstract than Active Record, here the mapping between DB and Object is made explicit and separated from the objects that get created into a Mapper (or Mappers). Hibernate is probably the best known implementor of this pattern.</para>
      </speakernotes>
    </foil>
    <foil>
      <title>Setting up DataMapper (the library)</title>
      <para>We're going to be using the Ruby library DataMapper to bridge between database and objects. 
        As it's name suggests, it was inspired by the Data Mapper pattern. In actual fact it ends up being
        a bit of a cross between Active Record and Data Mapper, but it does make the mapping between DB and
        Object explicit.</para>
    </foil>
    <foil>
      <title>Adding to the Gemfile</title>
      <para>If you don't already have DataMapper listed in the Gemfile for your app it needs to be added:</para>
      <programlisting language="ruby"><xi:include href="ex/dm-gemfile.rb" parse="text"/></programlisting>
    </foil>
    <foil>
      <title>Adding the setup code to the app</title>
      <programlisting language="ruby"><xi:include href="ex/app-dm_setup.rb" parse="text"/></programlisting>
    </foil>
    <foil>
      <title>Defining the Comment model</title>
      <programlisting language="ruby"><xi:include href="ex/comment-model.rb" parse="text"/></programlisting>
    </foil>
    <foil>
      <title>Creating the database</title>
      <para>We're using SQLite, so the database is automatically created for us, and
        the call to <code>DataMapper::auto_upgrade!</code> generates tables
        based on our model</para>
    </foil>
  </foilgroup>
  <foilgroup>
    <title>POSTing data back to the app</title>
    <foil>
      <title>HTML forms</title>
      <programlisting language="html+erb"><xi:include href="ex/comment-form.erb" parse="text"/></programlisting>
    </foil>
    <foil>
      <title>Nested params</title>
      <para>Rack translates forms like this:</para>
      <programlisting language="html+erb"><xi:include href="ex/nested_params-form.erb" parse="text"/></programlisting>
      <para>Into a <code>params</code> hash like this:</para>
      <programlisting language="ruby"><xi:include href="ex/nested_params-hash.rb" parse="text"/></programlisting>
    </foil>
  </foilgroup>
  <foilgroup>
    <title>Processing POST data</title>
    <foil>
      <title>The <code>params</code> hash</title>
      <para>The <code>params</code> hash contains all the data passed to our app in a request:</para>
      <itemizedlist>
        <listitem><simpara>Route segments</simpara></listitem>
        <listitem><simpara>Query string params (also GET form data)</simpara></listitem>
        <listitem><simpara>POSTed form data</simpara></listitem>
      </itemizedlist>
      <para>For example, given the route <code>/plays/:id/act/:act_number</code> POSTing the previous form to <code>/plays/caesar/act/1</code> would yield a params hash like:</para>
      <programlisting language="ruby"><xi:include href="ex/params-hash.rb" parse="text"/></programlisting>
    </foil>
    <foil>
      <title>Using the params hash</title>
      <para>You get to the params hash using the <code>params</code> method in your app.</para>
      <programlisting language="ruby"><![CDATA[
get "/act/:id" do
  "Hello, #{params['id']}"
end
]]></programlisting>
    </foil>
    <foil>
      <title>Creating a Comment</title>
      <programlisting language="ruby"><xi:include href="ex/comment-create.rb" parse="text"/></programlisting>
    </foil>
    <foil>
      <title>Creating a Comment - associating with an Act</title>
      <programlisting language="ruby"><xi:include href="ex/comment-with_association.rb" parse="text"/></programlisting>
    </foil>
    <foil>
      <title>Creating a Comment for an Act</title>
      <programlisting language="ruby"><xi:include href="ex/comment-create-with_association.rb" parse="text"/></programlisting>
    </foil>
    <foil>
      <title>Redirecting</title>
      <para>Rendering the Act show view after creation opens us up to replay: reloading the page will simply create a duplicate comment.</para>
      <para>After methods that mutate the state of the system, we should issue an HTTP redirect to somewhere sensible (In this case, to the Act URL)</para>
      <programlisting language="ruby"><xi:include href="ex/comment-create_with_redirect.rb" parse="text"/></programlisting>
    </foil>
  </foilgroup>
  <foilgroup>
    <title>Displaying the results</title>
    <foil>
      <title>Showing Comments</title>
      <para>Let's add comments to the end of the Act page</para>
      <itemizedlist>
        <listitem><para>How do we fetch comments for a page?</para></listitem>
        <listitem><para>How do we get them into the view?</para></listitem>
      </itemizedlist>
    </foil>
    <foil>
      <title>Fetching comments</title>
      <programlisting language="ruby"><xi:include href="ex/comment-act-fetch_comments.rb" parse="text"/></programlisting>
    </foil>
    <foil>
      <title>Getting comments into the page</title>
      <programlisting language="html+erb"><xi:include href="ex/comment-act-view.erb" parse="text"/></programlisting>
    </foil>
  </foilgroup>
</slides>
