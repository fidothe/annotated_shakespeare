<?dbhtml pygments="true"?>
<slides xml:lang="en" xmlns="http://docbook.org/ns/docbook"
  xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink">
  <info>
    <title>Practical Web Applications</title>
    <subtitle>Security and Authentication</subtitle>
    <!-- authors are alphabetical by first name (I get sick of being listed last all the time, 
so I always do this if I can) -->
    <authorgroup>
      <author>
        <personname>
          <firstname>Lauren</firstname>
          <surname>Wood</surname>
        </personname>
        <affiliation>
          <orgname>Textuality Services, Inc.</orgname>
        </affiliation>
      </author>
      <author>
        <personname>
          <firstname>Matt</firstname>
          <surname>Patterson</surname>
        </personname>
        <affiliation>
          <orgname>Constituent Parts, Ltd.</orgname>
        </affiliation>
      </author>
      <author>
        <personname>
          <firstname>Norman </firstname>
          <surname>Walsh</surname>
        </personname>
        <affiliation>
          <orgname>MarkLogic</orgname>
        </affiliation>
      </author>
      <author>
        <personname>
          <firstname>Paul</firstname>
          <surname>Downey</surname>
        </personname>
        <affiliation>
          <orgname>GDS</orgname>
        </affiliation>
      </author>
    </authorgroup>
    <releaseinfo role="version">Version 1.0</releaseinfo>
    <legalnotice>
      <para>Alpha by first name</para>
    </legalnotice>
    <pubdate>2012-09-20</pubdate>
    <copyright>
      <year>2012</year>
      <holder>Lauren Wood, Matt Patterson, Norm Walsh, Paul Downey</holder>
    </copyright>
  </info>
  <foilgroup>
    <title>Identity Concepts</title>
    <foil>
      <title>Facets of Identity</title>
      <itemizedlist>
        <listitem>
          <para>Who am I today? Or now?</para>
        </listitem>
        <listitem>
          <para>Role I’m playing right now </para>
        </listitem>
        <listitem>
          <para>Identity depends on what I’m doing </para>
        </listitem>
        <listitem>
          <para>Anonymous vs pseudonymous vs Real Names</para>
        </listitem>
      </itemizedlist>
      <speakernotes>
        <para>Identity: the overarching “who am I” – or rather, what persona am I using for this
          purpose? Identity is multi-faceted – checking my personal mail, or auditing the financial
          records for a large corporation are manifestations of different identities, even if I’m
          the same person carrying out both activities. I may have to use a real name for some
          activities, for others I can use a pseudonym, for others I can use a one-off “handle” or
          no label at all. </para>
      </speakernotes>
    </foil>
    <foil>
      <title>Authentication</title>
      <para>Am I talking to the person I think I’m talking to? </para>
      <para>Is it the person, or someone using their computer? </para>
      <para>How sure do I have to be that it’s the right person? </para>
      <para>Levels of identification and authentication depend on application. </para>
      <para>“Something you are, something you have, something you know” </para>
      <para>Identity verification (proofing) - digital version of notaries?</para>
      <speakernotes>
        <para>who am I really talking to? Note the associated issues of is it really the person, or
          is it someone using that person’s credentials? In real life we have notaries who will
          check your identification and assert as a trusted third party that it was really you; in
          the digital arena we don’t have anything with the same level of guarantee. The trinity of
          “something you have (e.g., token, card), something you know (e.g., password), something
          you are (e.g., biometric)” helps, as each separate item requires a separate check of the
          authentication. Identity verification is separate to authentication. Also called identity
          proofing. This is mapping a digitally-used identity back to a real person. Every time the
          person shows up with the digital id, want to prove they do go back to the real person. US
          gov tries to add trust, chain of custody that’s strong enough to go back to the real world
          – can you make the proof strong enough if someone did something wrong etc. </para>
      </speakernotes>
    </foil>
    <foil>
      <title>Authorisation</title>
      <para>Is this person allowed to do what they want to do? </para>
      <itemizedlist>
        <listitem>
          <para>as an individual </para>
        </listitem>
        <listitem>
          <para>as a member of a group </para>
          <para>static name list of all allowed to do “X”</para>
        </listitem>
        <listitem>
          <para>with a particular role </para>
          <para>assign role to person; everyone with that role allowed to do “Y”</para>
        </listitem>
      </itemizedlist>
      <speakernotes>
        <para>Typically used in enterprises; the big problem is trying to minimise the number of
          roles so you don’t have each person having their own role! Groups are static, but a good
          first step to figuring out the roles.</para>
      </speakernotes>
    </foil>
    <foil>
      <title>And the rest</title>
      <para>Confidentiality</para>
      <itemizedlist>
        <listitem>
          <para>only the right people can see this</para>
        </listitem>
      </itemizedlist>
      <para>Auditing </para>
      <itemizedlist>
        <listitem>
          <para>track who accessed the system and what they did </para>
        </listitem>
      </itemizedlist>
      <para>Integrity</para>
      <itemizedlist>
        <listitem>
          <para>did the information arrive whole and untouched?</para>
        </listitem>
      </itemizedlist>
    </foil>
    <foil>
      <title>Trust and other nebulous aspects</title>
      <para>Technical aspects </para>
      <itemizedlist>
        <listitem>
          <para>exchange public keys and metadata </para>
        </listitem>
      </itemizedlist>
      <para>Legal level </para>
      <itemizedlist>
        <listitem>
          <para>contracts, agreements </para>
        </listitem>
      </itemizedlist>
      <para>Policy</para>
      <itemizedlist>
        <listitem>
          <para>what are the conditions for our working together?</para>
        </listitem>
      </itemizedlist>
      <para>Non-repudiation</para>
      <itemizedlist>
        <listitem>
          <para>how do we make orders irrevocable?</para>
        </listitem>
      </itemizedlist>
      <speakernotes>
        <para>trust (how do I know I can trust you or your system?), policy (have we actually agreed
          that we can work together?), and non-repudiation (so they can’t claim afterwards it wasn’t
          them sending the request). Non-repudiation needs a high level of assurance that the
          authentication is accurate, and depends on the integrity of the data to make sure fake
          data wasn’t sent or received. </para>
      </speakernotes>
    </foil>
    <foil>
      <title>Summary</title>
      <informaltable border="1" cellpadding="1">
        <tr>
          <th>Requirement</th>
          <th>Technologies</th>
        </tr>
        <tr>
          <td>Authentication</td>
          <td> Username/password, key-based digital signing, challenge-response, biometrics, smart
            cards </td>
        </tr>
        <tr>
          <td>Authorisation</td>
          <td> Policy engines, directory attributes, access control, digital rights management,
            active directory </td>
        </tr>
        <tr>
          <td>Auditing</td>
          <td> Secure logging + analysis </td>
        </tr>
        <tr>
          <td>Integrity</td>
          <td> Message digest, authenticated with a digital signature </td>
        </tr>
        <tr>
          <td>Confidentiality</td>
          <td> Key-based digital encryption and decryption </td>
        </tr>
        <tr>
          <td>Non-repudiation</td>
          <td> Key-based digital signing and signature verification, message reliability,
            legal/contractual agreements </td>
        </tr>
        <tr>
          <td>Trust</td>
          <td>Setting up parameters for all the above </td>
        </tr>
      </informaltable>
    </foil>
  </foilgroup>
  <foilgroup>
    <title>HTTP-based authentication</title>
    <foil>
      <title>HTTP Basic authentication</title>
      <para>Basic authentication - HTTP 1.0, 1999, RFC 2617</para>
      <itemizedlist>
        <listitem>
          <para>widely implemented </para>
        </listitem>
        <listitem>
          <para>not secure, password sent in clear text </para>
        </listitem>
        <listitem>
          <para>protects resources in authentication realm </para>
        </listitem>
      </itemizedlist>
      <mediaobject role="center">
        <alt>application architecture components</alt>
        <imageobject>
          <imagedata fileref="../images/httpbasicauth.svg"/>
        </imageobject>
      </mediaobject>
      <speakernotes>
        <para> isn’t particularly secure, but it is easy to implement. The page(s) that require the
          password are said to be in an authentication realm, which is usually all the pages in a
          particular directory on the web site. When the browser asks to be shown one of those
          pages, the HTTP server responds with a 401 code (Unauthorized) and typically the name of
          the authentication realm. The browser typically then puts up a dialog box, asking for the
          username and password. The credentials are concatenated, base64-encoded (for ease of
          handling, not security), and sent to the server. If the credentials are accepted, the
          server sends the page back to the browser for display. The big security hole with this one
          is that the username and password are sent as plain text (base-64 encoding doesn’t add any
          security as it’s trivial to decode the string). If you use SSL or some other method to
          secure the channel (the way the information is sent from point A to point B), then this is
          ok. If you don’t, then someone sitting in between the two end-points could pick up the
          information. </para>
      </speakernotes>
    </foil>
    <foil>
      <title>HTTP Digest authentication</title>
      <itemizedlist>
        <listitem>
          <para>Encrypts the password using cryptographic hash aka digest</para>
        </listitem>
        <listitem>
          <para>Cryptographic hash is effectively impossible to break</para>
        </listitem>
        <listitem>
          <para>Quick to compute the digest from the string</para>
        </listitem>
        <listitem>
          <para>Security further improved by using a nonce (random number, generated on server, that
            changes each time the client gets the 401)</para>
        </listitem>
        <listitem>
          <para>Easier to implement/use HTTP Basic over SSL/TLS than HTTP Digest</para>
        </listitem>
      </itemizedlist>
      <speakernotes>
        <para>encrypts the password using a cryptographic hash system. A cryptographic hash function
          is a procedure that takes some data (the message) and gives you back a fixed-size string,
          called a cryptographic hash, message digest, or digest (hence the name of HTTP Digest).
          The idea of the cryptographic hash is that it’s incredibly hard to create a message with a
          given digest, it’s incredibly hard to modify a message without changing the digest, and
          it’s incredibly hard to find two messages that have the same digest. “Incredibly hard” is
          often called “infeasible”, or “effectively impossible”. So if you store (or pass) your
          password in digest form, it should be effectively impossible to break the digest to figure
          out the password. But it’s quick to compute the digest for a password the user inputs, and
          compare that to the stored digest. HTTP Digest uses a standard cryptographic hash
          function, called MD5, which generates a 32-digit hexadecimal number. It’s not perfect and
          in fact was considered to be broken in 2004-5, but it is still widely used outside of
          government applications. The security can be improved by using a “nonce” (number used
          once), which is a random number generated on the server that is changed each time the
          client receives that 401 code we discussed previously. So now the client has to take the
          username, the authentication realm name, the password, and the nonce, and create the MD5
          hash of all of that information to send to the server. This is more secure than the plain
          text version! And for additional security, the client may also generate a nonce, hashing
          it with all the other information. As always, there are more details and I’ve skimmed over
          most of the finer points. And in practice, most sites use HTTP Basic over SSL/TLS rather
          than implementing HTTP Digest. </para>
      </speakernotes>
    </foil>
    <foil>
      <title>Summary: HTTP authentication</title>
      <para>Based on password authentication </para>
      <itemizedlist>
        <listitem>
          <para>weak authentication (only one factor) </para>
        </listitem>
        <listitem>
          <para>people tend to forget their passwords </para>
        </listitem>
        <listitem>
          <para>solutions to forgetting often not secure </para>
        </listitem>
        <listitem>
          <para>easy to implement </para>
        </listitem>
        <listitem>
          <para>suitable for “don’t need much protection” resources </para>
        </listitem>
        <listitem>
          <para>Digest more secure but harder to use </para>
        </listitem>
        <listitem>
          <para>Use Basic over SSL for reasonable security</para>
        </listitem>
        <listitem>
          <para>Encrypt your passwords in storage</para>
        </listitem>
      </itemizedlist>
    </foil>
  </foilgroup>
  <foilgroup>
    <title>Outsourcing identity</title>
    <foil>
      <title>Why?</title>
      <para>Best principle for keeping user data around:</para>
      <para role="center"><emphasis>DON’T</emphasis></para>
      <itemizedlist>
        <listitem>
          <para>Treat PII as radioactive, keep as little as possible.</para>
        </listitem>
        <listitem>
          <para>Push responsibility (and support costs for lost passwords) onto someone else.</para>
        </listitem>
        <listitem>
          <para>They might even implement higher security (two or three-factor
            authentication).</para>
        </listitem>
        <listitem>
          <para>Your users may use Google/Twitter/Facebook anyway.</para>
        </listitem>
      </itemizedlist>
      <para>But...</para>
      <itemizedlist>
        <listitem>
          <para>what happens if that company closes down?</para>
        </listitem>
        <listitem>
          <para>what happens if that company misuses the information?</para>
        </listitem>
        <listitem>
          <para>what happens if that company changes its terms of use?</para>
        </listitem>
      </itemizedlist>
      <speakernotes>
        <para>If you’re creating a web-based application, or web site that has users you want to be
          able to identify or disambiguate in some way (whether or not you require real names or
          anything that looks like a real name), the standard rule is to treat all personally
          identifiable information as if it were radioactive. I.e., keep as little as possible for
          as short a time as possible. Depending on what your application does, or who your probable
          users are, it might be a good idea to “outsource” your authentication by asking the user
          to sign in with Twitter, or Facebook, or a Google account. This can have its downsides –
          can I be sure that Twitter won’t somehow misuse the information? What happens when/if
          they’re bought or close down? In the meantime, however, it’s not a bad model and saves
          having to handle those lost password queries. </para>
        <para>company may also change TOC and not let you access its user database any more, e.g.,
          twitter if you have too many users.</para>
      </speakernotes>
    </foil>
    <foil>
      <title>Sign in with...</title>
      <informaltable border="1" cellpadding="1">
        <tr>
          <th>Specification</th>
          <th>Who uses it</th>
          <th>Notes</th>
        </tr>
        <tr>
          <td>OAuth 1</td>
          <td>Twitter, LinkedIn.</td>
          <td>Incompatible with, and (theoretically) obsoleted by, OAuth 2. </td>
        </tr>
        <tr>
          <td>OAuth 2</td>
          <td>Facebook, github, Salesforce, lots of others</td>
          <td>Became an RFC in July 2012. Designed for authorising access to resources, rather than
            for outsourcing authentication, but widely used for authentication, e.g., <link
              xlink:href="https://developers.facebook.com/docs/authentication">Facebook</link>.
          </td>
        </tr>
        <tr>
          <td>OpenID</td>
          <td>Google, Paypal as IdPs, many websites accept it for sign-in</td>
          <td> The user can register at any provider (including their own website), then use that
            login to log in at any site that accepts those registrations. UI issues make it
            inconvenient. Original use case was for blog comments to prevent spam; original design
            had security issues. Some of these security issues were fixed in OpenID 2, which Google
            and Paypal support. </td>
        </tr>
        <tr>
          <td>OpenID Connect</td>
          <td>Google, likely to increase</td>
          <td>Identity layer on top of OAuth 2.0. Uses the authorisation server to provide
            authentication and some user profile information.</td>
        </tr>
        <tr>
          <td>Persona (was browserID)</td>
          <td>Mozilla (persona.org)</td>
          <td>Uses user's email address (provided by a primary identity authority) to authenticate
            to a third-party identity provider (called an implementation provider, or secondary
            identity authority). This may be in the web browser (e.g., Firefox) or server
            (persona.org). Not widely implemented, some confusion with OpenID, some security
            issues.</td>
        </tr>
      </informaltable>
      <speakernotes>
        <para>Twitter uses OAuth as the protocol. Facebook uses OAuth 2. Mozilla started Persona
          (browserID), but this is not taking off all that fast and doesn't seem to work for mobile
          apps. Google mail (for example) should be able to support it as a primary identity
          authority, but I haven't found it documented anywhere that it actually does. We're going
          to use it in our app, but more because it's easy than because it's better.</para>
        <para>Some other services use OpenID. Like OAuth, OpenID uses the standard HTTP
          request-response mechanism to ask for authentication. The user can register at any
          provider, then use that login to log in at any site that accepts those registrations. The
          original use case was to provide some sort of way to allow blog comments from people and
          cut down on the spam. The user just has to remember one username/password and can log in
          at multiple places. And you don’t need to trust that shiny new site with any personal
          information (other than your username and which OP you use) that you have stored at your
          OpenID Provider, you can decide yourself how much information to let it have.
          Persona/browserID is similar, but uses an email address rather than a URL for
          identification.</para>
        <para>OpenID Connect is new, still in draft form, but likely to be important. Google
          supports it and Microsoft contributed to the specification. Basically it sends the user to
          an OAuth authorization server for authentication and authorization, which one would expect
          should be possible. Facebook's authentication works in a similar way to OpenID Connect
          with a few small technical differences. In other words, it's not really OpenID at all, it
          just (mis) uses the name.</para>
        <para>The IdP is the authoritative source for information about the user, not just the place
          where the user stores some resource. In a sense, we now want to use the service provider
          as a source of metadata, not just data (if you think of info about the user as being
          metadata, and what they have there is the data). E.g., Twitter stores your name, your
          email, the city you live in, and a description that you supply. An application can use
          some of that and theoretically doesn’t need to store it itself. Google allows this through
          the OpenID attribute exchange protocol.</para>
      </speakernotes>
    </foil>
    <foil>
      <title>The "classic" roles</title>
      <mediaobject role="center">
        <alt>Roles - identity provider, relying party, user</alt>
        <imageobject>
          <imagedata fileref="../images/three_identity_roles.svg"/>
        </imageobject>
      </mediaobject>
      <para>In these flows, there are three roles (parties) - the identity provider, the relying
        party, and the user.</para>
      <para>Tokens (credentials) are exchanged between the actors representing either the actor or
        the authentication/authorisation.</para>
      <speakernotes>
        <para>These credentials (such as username and password, or public/private key pair) may be
          encrypted or signed, depending on the protocol, or it may be expected that all information
          is passed via TLS/SSL. There are a number of different systems for this; I'll introduce a
          couple of them, and then we'll add one to our application. </para>
      </speakernotes>
    </foil>
    <foil>
      <title>OpenID flows</title>
      <para>Designed for outsourcing identity. Original use case: for using with blog comments or
        similar (i.e., not high security)</para>
      <mediaobject role="center">
        <alt>More roles</alt>
        <imageobject>
          <imagedata fileref="../images/OpenId-flow.png"/>
        </imageobject>
      </mediaobject>
      <speakernotes>
        <para>OpenID was only semi-successful – when we implemented it at Sun we had very few people
          sign up, and even those who signed up seldom used it. One of the big reasons was simply
          that it adds an extra layer. Every time you wanted to go to some web site and do
          something, you had to sign in again, doing the authentication dance, for not much benefit.
          The security in OpenID 1.0 was also not very good (for example, it’s easy to phish for
          information, but see also https://sites.google.com/site/openidreview/issues) so that Sun
          (as an example) couldn’t recommend people use it for anything sensitive or important. Some
          of those issues were fixed with OpenID 2 (or at least detailed so implementers could
          choose to fix them) and through more awareness of the issues. In general OAuth has taken
          over and is a lot more widely implemented. </para>
        <para>This doesn’t mean the OpenID is dead: many companies still support it, such as Google.
          Google uses OpenID for Google Apps support. They have a hybrid OAuth/OpenID for login.
          OpenID Connect, which is more or less OpenID on top of OAuth. Google has been
          strategically backing OpenID as they put money in it. Paypal also uses OpenID, so
          depending on where you want to outsource your information to, you may need to support it.
        </para>
      </speakernotes>
    </foil>
    <foil>
      <title>More roles</title>
      <para>Role proliferation</para>
      <mediaobject role="center">
        <alt>More roles</alt>
        <imageobject>
          <imagedata fileref="../images/more_identity_roles.svg"/>
        </imageobject>
      </mediaobject>
      <speakernotes>
        <para>The top four are for OAuth 2, the bottom three are for browserID. Note the different
          names for each. The flows aren't shown here, as basically everything talks to everything
          at some stage, passing tokens back and forth, so it gets complicated. More details as we
          get to them. BrowserID is up next, then OAuth 2.</para>
      </speakernotes>
    </foil>
    <foil>
      <title>BrowserID roles</title>
      <mediaobject role="center">
        <alt>BrowserID roles</alt>
        <imageobject>
          <imagedata fileref="../images/browseridroles.svg"/>
        </imageobject>
      </mediaobject>
      <speakernotes>
        <para>Primary Identity Authorities (primary) - Services that directly provide the user with
          an identity in the form of an email address. Example primaries include Yahoo! mail or
          gmail, except they don't support this.</para>
        <para>Implementation Provider (or IP) - This may be the user's web browser if native support
          for BrowserID exists, otherwise browserid.org or login.persona.org. These implement the
          client portion of the system. In addition to key management and implementation, the IP
          also serves as a Secondary Identity Authority. </para>
        <para>The system has some security concerns, we'll talk more about that in the next phase.
          it's implemented with JavaScript and relies on cross-document messaging, an API defined in
          HTML 5.</para>
      </speakernotes>
    </foil>
    <foil>
      <title>BrowserID/Persona implementation</title>
      <para>Simple, but assumes user has a browser with JavaScript, and has signed up at
        persona.org.</para>
      <orderedlist>
        <listitem>
          <para>Include the persona Javascript library (as link to persona.org).</para>
        </listitem>
        <listitem>
          <para>Add <guibutton>login</guibutton> and <guibutton>logout</guibutton> buttons, and code
            with <function>onclick</function> functions.</para>
        </listitem>
        <listitem>
          <para>Set up a <function>watch</function> function to watch for those actions.</para>
        </listitem>
        <listitem>
          <para>Verify the credentials (called identity assertions) by POSTing to persona.org.
          </para>
        </listitem>
      </orderedlist>
      <para>There are a number of best practices for security.</para>
    </foil>
    <foil>
      <title>Exercise</title>
      <para>Try it out!</para>
    </foil>
    <foil>
      <title>The Authentication layer</title>
      <para>We're going to be using OmniAuth, a ruby library for dealing with a wide variety of authentication providers.</para>
      <para><link xlink:href="https://github.com/intridea/omniauth/">github.com/intridea/omniauth/</link></para>
    </foil>
    <foil>
      <title>The controller side</title>
      <programlisting language="ruby"><![CDATA[
require 'user'
require 'credential'
require 'omniauth-browserid'
class AnnotatedShakespeare < Sinatra::Base
  set :session_secret, "df207bff3e06bba635a9e4f334238801"
  enable :sessions

  use OmniAuth::Builder do
    provider :developer
  end

  # Support both GET and POST for OmniAuth callbacks
  [:get, :post].each do |method|
    send(method, "/auth/:provider/callback") do
      puts env['omniauth.auth'].inspect
      session['user'] = env['omniauth.auth']['uid']
      redirect to('/')
    end
  end
]]></programlisting>
      <para><code>lib/annotated_shakespeare.rb</code></para>
    </foil>
    <foil>
      <title>In the views</title>
      <programlisting language="html+erb"><![CDATA[
<body>
  <% if session['user'] %>
    <p>Welcome back, <%= session['user'] %></p>
  <% else %>
    <p><a href="/auth/developer">Log in</a>.</p>
  <% end %>
  <%= yield %>
</body>
]]></programlisting>
      <para><code>views/layout.erb</code></para>
    </foil>
    <foil>
      <title>The User model</title>
      <para>We need a <code>User</code> model to represent users in our system. Once we have a User then we can connect them to an authentication provider.</para>
    </foil>
    <foil>
      <title>The basic model</title>
      <programlisting language="ruby"><![CDATA[
require 'data_mapper'
class User
  include DataMapper::Resource
  property :id, Serial
  property :name, String
  has n, :credentials
]]></programlisting>
      <para><code>lib/user.rb</code></para>
      <programlisting language="ruby"><![CDATA[
require 'data_mapper'
class Credential
  include DataMapper::Resource
  property :id, Serial
  property :provider, String
  property :token, String
  belongs_to :user
end
]]></programlisting>
      <para><code>lib/credential.rb</code></para>
    </foil>
    <foil>
      <title>Credential?</title>
      <para>We're modelling Users and Credentials separately, because we're going to be connecting multiple authentication providers to a single User.</para>
      <para><emphasis>Caveat:</emphasis> In real life you'd want to think very carefully about modelling things in this way. It'd be better to start with storing credentials directly on the User model, and change the model when you really needed to. We don't really have the time today...</para>
    </foil>
    <foil>
      <title>Creating Users</title>
      <itemizedlist>
        <listitem><para>Hand off to Auth provider</para></listitem>
        <listitem><para>If valid user details returned, create User and associate auth Credential</para></listitem>
        <listitem><para>Store User ID in the <code>session</code></para></listitem>
        <listitem><para>Redirect the browser back to where it was before...</para></listitem>
      </itemizedlist>
    </foil>
    <foil>
      <title>Logging in existing Users</title>
      <itemizedlist>
        <listitem><para>Hand off to Auth provider</para></listitem>
        <listitem><para>Check if we already have a User who matches the user details returned.</para></listitem>
        <listitem><para>Otherwise, create User and associate auth Credential</para></listitem>
        <listitem><para>Store User ID in the <code>session</code></para></listitem>
        <listitem><para>Redirect the browser back to where it was before...</para></listitem>
      </itemizedlist>
    </foil>
    <foil>
      <title>In the controller</title>
      <programlisting language="ruby"><![CDATA[
[:get, :post].each do |method|
  send(method, "/auth/:provider/callback") do
    if user = User.from_auth_provider(
        params[:provider], env['omniauth.auth']['uid']
      )
      destination = '/'
    else
      user = User.create_from_auth_provider(
        params[:provider], env['omniauth.auth']['uid']
      )
      destination = '/profile'
    end
    session['user'] = user.id
    redirect to(destination)
  end
end
]]></programlisting>
      <para><code>lib/annotated_shakespeare.rb</code></para>
    </foil>
    <foil>
      <title>Model find &amp; create convenience methods</title>
      <programlisting language="ruby"><![CDATA[
class User
  def self.from_auth_provider(provider, token)
    credential = Credential.first(
      :provider => provider, :token => token)
    return credential.user if credential
    nil
  end

  def self.create_from_auth_provider(provider, token)
    user = User.create!
    credential = Credential.create!(
      :provider => provider, :token => token, 
      :user => user)
    user
  end
end
]]></programlisting>
      <para><code>lib/user.rb</code></para>
    </foil>
    <foil>
      <title>In the views</title>
      <programlisting language="html+erb"><![CDATA[
<body>
  <% if current_user %>
    <p>Welcome back, <%= current_user.name %></p>
    <p><a href="<%= url('/logout') %>">Logout</a></p>
  <% else %>
    <p><a href="/auth/developer">Log in</a>.</p>
  <% end %>
  <%= yield %>
</body>
]]></programlisting>
      <para><code>views/layout.erb</code></para>
    </foil>
    <foil>
      <title>Back in the controller</title>
      <programlisting language="ruby"><![CDATA[
helpers do
  def current_user
    if session['user']
      @user ||= User.get(session['user'])
    end
  end
end
]]></programlisting>
      <para><code>lib/annotated_shakespeare.rb</code></para>
    </foil>
    <foil>
      <title>Back in the controller</title>
      <programlisting language="ruby"><![CDATA[
get '/profile' do
  halt 403 unless current_user
  erb :profile
end

post '/profile' do
  halt 403 unless current_user
  current_user.name = params[:name]
  current_user.save!
  redirect to('/')
end
]]></programlisting>
      <para><code>lib/annotated_shakespeare.rb</code></para>
    </foil>
    <foil>
      <title>Back in the controller</title>
      <programlisting language="ruby"><![CDATA[
get '/logout' do
  if current_user
    session.clear
    redirect to('logout')
  else
    erb :logout
  end
end
]]></programlisting>
      <para><code>lib/annotated_shakespeare.rb</code></para>
    </foil>
    <foil>
      <title>In the views (again)</title>
      <programlisting language="html+erb"><![CDATA[
<form action="/profile" method="POST">
  <input name="name" 
    value="<%= current_user ? current_user.name : "" %>"
    type="text">
  <input type="submit" value="Save">
</form>
]]></programlisting>
      <para><code>views/profile.erb</code></para>
      <programlisting language="html+erb"><![CDATA[
<p>Logged out!</p>
]]></programlisting>
      <para><code>views/logout.erb</code></para>
    </foil>
    <foil>
      <title>Taking stock</title>
      <para>You should now be able to log in and log out. The <code>developer</code> strategy which comes with OmniAuth just gives you back whatever you put in. Now we're confident that the pieces are working, let's swap in a real authentication system.</para>
    </foil>
  </foilgroup>
  <foilgroup>
    <title>Implementing Browser ID/Persona</title>
    <foil>
      <title>The Omniauth code</title>
      <para>Let's add authentication using Browser ID (now called Mozilla Persona)</para>
      <programlisting language="ruby"><![CDATA[
use OmniAuth::Builder do
  provider :developer
  provider :browser_id, 
    :verify_url => 'https://verifier.login.persona.org
/verify'
end
]]></programlisting>
      <para><code>lib/annotated_shakespeare.rb</code></para>
      <programlisting language="html+erb"><![CDATA[
<p>Log in (or sign up) with <a href="/auth/browser_id">
Mozilla Persona</a>.</p>
]]></programlisting>
      <para><code>views/layout.erb</code></para>
    </foil>
    <foil>
      <title>What about Comments?</title>
      <para>Now we have actual users, let's tie comments to them.</para>
      <programlisting language="ruby"><![CDATA[
class Comment
  belongs_to :user
end
]]></programlisting>
      <para><code>lib/comment.rb</code></para>
      <programlisting language="ruby"><![CDATA[
class User
  has n, :comments
end
]]></programlisting>
      <para><code>lib/user.rb</code></para>
    </foil>
    <foil>
      <title>What about Comments?</title>
      <programlisting language="ruby"><![CDATA[
post '/plays/:id/act/:act_number/comments' do
  halt 403 unless current_user
  ...
  current_user.comments.create!(
    :body => params['comment']['body'],
    :commentable_type => :act, 
    :commentable_id => @act.number)
  ...
end
]]></programlisting>
      <para><code>lib/annotated_shakespeare.rb</code></para>
    </foil>
  </foilgroup>
  <foilgroup>
    <title>OAuth 2</title>
    <foil>
      <title>Use Case for OAuth</title>
      <para>Hybrid authentication/authorisation </para>
      <itemizedlist>
        <listitem>
          <para>Allow applications to do things on my behalf </para>
        </listitem>
        <listitem>
          <para>Application doesn’t get my user name and password </para>
        </listitem>
        <listitem>
          <para>I can revoke access </para>
        </listitem>
      </itemizedlist>
      <para>Basis for OpenID Connect</para>
      <itemizedlist>
        <listitem>
          <para> user logs in, gets an artifact (OAuth token) </para>
        </listitem>
        <listitem>
          <para>artifact is exchanged for identity data at the IdP</para>
        </listitem>
      </itemizedlist>
      <speakernotes>
        <para>OAuth came about so that if I have a system where I want an application to do
          something on my behalf (e.g., tweet when I’ve posted a new blog entry, or have some other
          app print some of my photos from Flickr), I don’t have to give that application my Twitter
          username and password. As the user, I authenticate to Twitter and authorise this
          application to tweet on my behalf. Twitter gives the application token credentials (also
          called access token and access secret) to use when tweeting on my behalf, and that’s all
          the application has. So it can’t use my username and password for anything else. </para>
        <para>Note here we're using OAuth 2, which is incompatible with OAuth 1.</para>
      </speakernotes>
    </foil>
    <foil>
      <title>OAuth 2 roles</title>
      <mediaobject role="center">
        <alt>OAuth 2 roles</alt>
        <imageobject role="center">
          <imagedata fileref="../images/oauth2roles.svg"/>
        </imageobject>
      </mediaobject>
      <speakernotes>
        <para>The specification defines four roles: the resource owner (often the end-user), the
          client (the application asking for the resource), the resource server (where the protected
          resource is stored), and the authorization server. You will see all of these terms. Other
          terms you will see are identity provider, which is the same as the authorization server,
          and relying party, which is the resource server that is relying on the authentication
          provided by the identity provider.</para>
        <para>On the web, you can think of it as being the client (browser) accessing resources on
          the server on behalf of the end-user (who owns those resources), after getting
          authorisation from the authorisation server.</para>
        <para>In our example: if you want to add a comment or annotation to the play, you need to be
          authorised to do so, based on the authentication that you are you. We outsource the
          authorisation to alphagov (maybe, or maybe github). When you see a “sign in with” notice,
          some system (Google, Twitter, Facebook) is being used as the authorisation server. </para>
      </speakernotes>
    </foil>
    <foil>
      <title>OAuth 2 flows</title>
      <mediaobject role="center">
        <alt>OAuth 2 flows</alt>
        <imageobject role="center">
          <imagedata fileref="../images/oauth_protocol_flow.svg"/>
        </imageobject>
      </mediaobject>
      <speakernotes>
        <para>The client is the application, which has already registered at the various servers.
          The flow starts with the client asking the user (resource owner) to allow the client to
          access some protected resource. The user agrees, and the process sends a token called the
          authorisation grant.</para>
        <para>The client sends this authorisation grant on to the authorisation server which in some
          sense controls access to where the resources are hosted, and gets back an access
          token.</para>
        <para>The client sends this access token to the resource server, which then returns the
          protected resource itself.</para>
        <para>The various credentials that are passed around are crucial – they are what determine
          whether the client can access resources, and under what conditions. To start the whole
          ball rolling, the authorisation server needs to know what the client is, and some of its
          capabilities. So the client has to register with the authorisation server, providing the
          information the authorisation server requires, and it is given some form of client
          credentials. One is the client identifier, which isn’t secret. The client is also given
          some authentication credential such as a password, public/private key pair, or a string
          call a client secret, which are meant to be kept secret. </para>
        <para>The authorisation grant (authorization grant in American) is a credential that
          represents the resource owner’s authorisation to access those protected resources. It can
          take different forms, depending on the scenario. </para>
        <para>The access tokens are the credentials that the client (e.g., the browser) uses to
          actually access those protected resources. This is a string that that contains information
          on the scope of the access (e.g., only certain pages) and the duration (one day, one year,
          forever). The token may even define that the client has to go through some additional
          authentication process. There are different types of access tokens, defined by the
          resource server. This means not all clients can talk to all resource servers; clients have
          to be configured to work with any given authorization server and/or resource server.
        </para>
      </speakernotes>
    </foil>
    <foil>
      <title>OAuth 2 clients</title>
      <para>Client: application wanting access to the resources on the user's behalf. Comes in two
        types.</para>
      <itemizedlist>
        <listitem>
          <para>confidential: can be trusted to keep credentials secret, and have to authenticate
            themselves to the authorisation server</para>
        </listitem>
        <listitem>
          <para>public: the rest</para>
        </listitem>
      </itemizedlist>
      <para>Expected to use TLS/SSL for authentication (OAuth 1 signed everything instead).</para>
      <speakernotes>
        <para>Clients come in two types. Confidential clients can be trusted to keep all the
          information for accessing the authorisation server secret, and have to authenticate
          themselves to the authorisation server. Public clients can’t be trusted to keep their
          client credentials secret, in other words they could be spoofed in some way. So although
          they may authenticate to the authorisation server, it’s not as trustworthy as a
          confidential client doing so. In general, all mobile applications and browser-based
          applications are public clients, since they could be hacked, or the information might be
          stored in clear text somewhere. The sort of credential we’re talking about is the client
          secret or client password. </para>
        <para>OAuth 2 expects that everyone uses TLS/SSL, both the server and client, so that all
          the traffic goes over a secure connection. This was controversial, and not all clients
          support TLS, in which case they’re meant to warn you (but may not). In particular,
          confidential clients must use TLS if they use passwords to authenticate at the
          authorisation server. OAuth 1 required that everyone use cryptographic signatures instead,
          which is a heavy burden on many implementers of client applications.</para>
      </speakernotes>
    </foil>
    <foil>
      <title>OAuth 2 client profiles</title>
      <para>Specific use cases for OAuth 2</para>
      <itemizedlist>
        <listitem>
          <para>web application</para>
          <para>Confidential client running on a web server. All credentials are stored on the web
            server. Resource owners access the client via the web (e.g., browser).</para>
        </listitem>
        <listitem>
          <para>user-agent-based application</para>
          <para>Public client where code is downloaded to user's system (e.g., runs in the browser).
            Credentials are often visible to the user, and could be hacked.</para>
        </listitem>
        <listitem>
          <para>native application</para>
          <para>Public client installed as native application on user's device. Client credentials
            can probably be exposed; dynamic access tokens may be safe.</para>
        </listitem>
      </itemizedlist>
      <speakernotes>
        <para>Reminder: The client has some authentication credential such as a password,
          public/private key pair, or a string call a client secret, which are meant to be kept
          secret. </para>
        <para>The authorisation grant (authorization grant in American) is a dynamic credential that
          represents the resource owner’s authorisation to access those protected resources. It can
          take different forms, depending on the scenario.</para>
        <para>The access tokens are the credentials that the client (e.g., the browser) uses to
          actually access those protected resources. This is a string that that contains information
          on the scope of the access (e.g., only certain pages) and the duration (one day, one year,
          forever). The token may even define that the client has to go through some additional
          authentication process. There are different types of access tokens, defined by the
          resource server. This means not all clients can talk to all resource servers; clients have
          to be configured to work with any given authorization server and/or resource server.
        </para>
      </speakernotes>
    </foil>
    <foil>
      <title>Real life implementation</title>
      <para>Our exercises are simplified. In real life you need to</para>
      <itemizedlist>
        <listitem>
          <para>secure any information you store on disk (e.g., access tokens) </para>
        </listitem>
        <listitem>
          <para>provide a trusted callback URI for the IdP to return the user to </para>
        </listitem>
        <listitem>
          <para>protect that URI with TLS/HTTPS to secure it </para>
        </listitem>
      </itemizedlist>
      <para>Where possible, reuse trusted libraries </para>
      <itemizedlist>
        <listitem>
          <para>they’ve been debugged</para>
        </listitem>
      </itemizedlist>
      <speakernotes>
        <para>In our exercises we’re not going to go to the bother of encrypting all the access
          tokens etc for storage as we would do in a real application – just like you would encrypt
          a password before storing it in a database, you should encrypt all secrets and tokens, not
          just when they’re being transferred from one place to another, but also for storage. We
          are, however, going to reuse an existing library rather than develop from scratch, not
          only because of time constraints, but also because getting the details right is hard.
          Where possible, reuse trusted libraries for your development. You also need to protect
          (with SSL/HTTPS) the callback endpoint and preregister it with servers (which is what
          Twitter does). The client has to have a callback URL where the server returns the user at
          the end of the authorization process. Ensure that this endpoint is protected with SSL/TLS
          and preregister it so that servers won’t mistakenly follow a endpoint dynamically provided
          by a rogue client.</para>
      </speakernotes>
    </foil>
    <foil>
      <title>Resources</title>
      <simplelist>
        <member>Getting Started with OAuth 2.0, 1st Edition by Ryan Boyd, O'Reilly</member>
        <member>OAuth 2 RFC: http://tools.ietf.org/html/draft-ietf-oauth-v2</member>
        <member>persona.org</member>
        <member>https://openid.net/specs/openid-connect-standard-1_0.html</member>
      </simplelist>
    </foil>
  </foilgroup>
  <foilgroup>
    <title>Web security basics</title>
    <subtitle>Connection-based security, message-based security, and some relevant
      standards</subtitle>
    <foil>
      <title>Connection-based security</title>
      <para>Secures the path between two end-points. </para>
      <para>Security is transient, only for the data in motion. </para>
      <para>Relatively simple to use, high performance. </para>
      <para>Point to point solution, doesn’t work across middle points.</para>
      <speakernotes>
        <para>Connection based security (like SSL) just secures the path between two endpoints. The
          security is transient in that it’s only active while a message is being transferred. Once
          a message is received it’s no longer encrypted. The advantage is that you can use this
          type of security for lots of different types of messages, it’s relatively high
          performance, and simple to use. The disadvantage is that you have to figure out how to
          secure the information (if it needs to be secured) once it’s arrived, and you can’t pass
          on the secure message as is, complete with its encryption. connection security as name is
          better than channel or transport. Protecting data in motion vs at rest.</para>
      </speakernotes>
    </foil>
    <foil>
      <title>HTTPS/TLS/SSL</title>
      <para>Adds encryption, signing, records, and session tracking to the basic HTTP </para>
      <orderedlist>
        <listitem>
          <para>browser sends request to port 443 with session ID, encryption algorithms it likes,
            random string, and requested website </para>
        </listitem>
        <listitem>
          <para>web site sends back server name, session ID, encryption algorithm, server version of
            the string, and server certificate </para>
        </listitem>
        <listitem>
          <para>browser decides whether to trust the certificate, checks the host name </para>
        </listitem>
        <listitem>
          <para>exchange tokens (secrets) to encrypt the data </para>
        </listitem>
        <listitem>
          <para>start exchanging encrypted data with session IDs and sequence numbers</para>
        </listitem>
      </orderedlist>
      <speakernotes>
        <para>This is often called SSL/TLS. SSL (Secure Sockets Layer) was the first name, and it
          was developed by Netscape. Eventually the IETF took over, and released a new version in
          1999, renamed Transport Layer Security (TLS). TLS is a record-based request-response
          format, with records of different types depending on where you are in the session. Instead
          of sending the request message as is to port 80 on a web server as for HTTP, the browser
          (client) kicks off the TLS session by sending a handshake to port 443. This is the
          handshake record, saying what time it is, which session ID (if any) this session ID has,
          which encryption algorithms the client supports (in order of preference), and which
          website the client is trying to reach (for the case that the IP address given supports
          multiple websites). It also includes 28 random bytes (we’ll get to those later). The web
          site responds, and let’s assume agrees with the requests, so the server sends back the
          server time, a session ID, and the encryption algorithm it will use, along with a server
          version of the 28 random bytes. It also sends the SSL Server Certificate, the basis of the
          trust system. Then the client decides whether (or not) to trust the certificate. The
          certificate is signed by a Certification authority (a company such as Verisign) using
          their private key. The client (browser) has a list of Certification authorities that it
          trusts, and that’s the basis of the trust that you put in the little lock sign on your
          browser. Once the client decides to approve that certificate, it checks whether the host
          name you sent the request to is the same as the name listed in the certificate. This is to
          prevent man-in-the-middle attacks, where someone sitting in between your client and the
          server you’re trying to reach can forge credentials. With the Certification authority
          signing the certificate, you can trust that the certificate is real (well, assuming you
          can trust that Certification authority). You can also add certificates that you trust
          yourself (hopefully for good reason!) to your list. </para>
        <para>http://www.moserware.com/2009/06/first-few-milliseconds-of-https.html</para>
        <para>OK, so we’re sure that we’ve reached the server and web site we wanted, and know which
          encryption algorithm they’ll use. We even have a session ID so we can avoid the handshake
          step for the rest of our session at that site. The client sends what’s called a
          “pre-master secret” to the server, a value that’s meant to be random and secret. Getting
          this value to be effectively random is hard and a number of implementers have discovered
          this the hard way, introducing security holes that were exploited. The pre-master secret
          should only be used for this one session as well. Then the client encrypts a padded
          version of the pre-master secret, and sends that to the server. The server calculates the
          master secret from the pre-master secret and the two random 28-byte values that the client
          and the server exchanged in the first handshake. These two secrets are used to derive all
          the session keys that are used to encrypt the actual HTTP request-response messages. There
          is also a sequence number, so that an attacked can’t simply copy one of the messages,
          change it, and resend (this is called a “replay” attack). The HTTP system acts as normal,
          and doesn’t need to worry about the encryption. It’s the TLS layer underneath that does
          all the work. The connection is closed when one side sends “closure alert” message. One
          point – you can use the same TLS system for other protocols, such as FTP, since it does
          sit underneath the protocol layer, but for this course we’re mostly interested in the
          HTTPS usage. </para>
      </speakernotes>
    </foil>
    <foil>
      <title>What is a Certificate?</title>
      <itemizedlist>
        <listitem>
          <para>Electronic document, typically in X.509 format</para>
        </listitem>
        <listitem>
          <para>Used in PKI (public key infrastructure) systems</para>
        </listitem>
        <listitem>
          <para>Includes a public key</para>
        </listitem>
        <listitem>
          <para>Includes identity information for person or corporation</para>
        </listitem>
        <listitem>
          <para>Includes hostname if intended to be used for TLS</para>
        </listitem>
        <listitem>
          <para>Digitally signed</para>
        </listitem>
        <listitem>
          <para>Signature attests that identity information and public key belong together</para>
        </listitem>
        <listitem>
          <para>Signature usually comes from a Certification Authority </para>
        </listitem>
      </itemizedlist>
      <speakernotes>
        <para>The certificate also commonly includes a serial number, algorithm used to create the
          digital signature, validity dates (from and to), the algorithm used to hash the
          certificate, the hash itself that proves the certificate has not been tampered with, and
          the purpose of the public key. Verisign (one of the big Certificate Authorities) has a
          number of classes of certificates, ranging from those used by individuals, to
          organizations, servers (these ones require independent verification), online business
          transactions, and governments. The EU has its own set of requirements for certificates,
          which are similar in concept. </para>
        <para>There are a number of issues with certificates, which I’m not going to go into here.
          Wikipedia has links to get you started.</para>
      </speakernotes>
    </foil>
    <foil>
      <title>Certificate Authorities</title>
      <para>An aside on certificate authorities </para>
      <itemizedlist>
        <listitem>
          <para>ultimate source of the trust in the system</para>
        </listitem>
        <listitem>
          <para>the authority signs the certificate</para>
        </listitem>
        <listitem>
          <para> what happens if the authority is hacked?</para>
        </listitem>
        <listitem>
          <para>what happens if the certificate authority is not trustworthy?</para>
        </listitem>
      </itemizedlist>
      <speakernotes>
        <para>While we’re on the subject, certificates can be revoked. When this happens, you should
          delete them from your “trusted” list. Unfortunately, few people know about this and even
          fewer check their certificates regularly to see if they have been revoked!</para>
        <para>Once the client decides to approve that certificate, it checks whether the host name
          you sent the request to is the same as the name listed in the certificate. This is to
          prevent man-in-the-middle attacks, where someone sitting in between your client and the
          server you’re trying to reach can forge credentials. With the Certification authority
          signing the certificate, you can trust that the certificate is real (well, assuming you
          can trust that Certification authority). You can also add certificates that you trust
          yourself (hopefully for good reason!) to your list.</para>
        <para>The main problem with certificates is that it’s turtles all the way up (or down). The
          certificate is signed by someone whose authority is attested to by another certificate,
          etc. Eventually you get to the top level, and there is a set of certificates that are
          built in as being fully trusted. These are usually issued by governments or organizations
          trusted by governments, or trusted by the browser or operating system manufacturer. In the
          DigiNotar case, they were sloppy and were hacked. Even though they were trusted by the
          Dutch government. The only solution is to completely distrust any certificates signed by
          them, as they may not actually have been signed by DigiNotar, but by the hacker.</para>
        <para>And there are alleged to be some certificate authorities in autocratic countries that
          are proxy-in-the-middle points, capable of passing on information to their governments.
          The solution to this is for the browser to not trust those authorities - but they have to
          know who they are first (some are known).</para>
      </speakernotes>
    </foil>
    <foil>
      <title>Message-based security</title>
      <para>Ties the security to the message</para>
      <itemizedlist>
        <listitem>
          <para>protects the data at rest</para>
        </listitem>
        <listitem>
          <para>remains secure once it’s received</para>
        </listitem>
        <listitem>
          <para>can use intermediaries who can’t read it</para>
        </listitem>
        <listitem>
          <para>tied to a particular format</para>
        </listitem>
        <listitem>
          <para>computationally expensive</para>
        </listitem>
        <listitem>
          <para>difficult to implement and use</para>
        </listitem>
      </itemizedlist>
      <speakernotes>
        <para>Message based security ties the security to the actual message so it remains secure
          even once it’s been received (we’re ignoring some security accelerators that strip out the
          security on the way for performance reasons). The security is persistent so that you can
          store the message (or part of the message; you don’t need to encrypt the whole thing) in
          its secured form and still see who signed it two years later. You can also implement a
          system where the message is sent via intermediaries, knowing they can’t read it. The
          disadvantage of message-based security is that it is typically tied to a particular
          message format (such as SOAP+WS-Security or S/MIME), is computationally expensive and
          often relatively complex to implement and use. It’s especially complicated if you want
          long-running message conversations, where you need to figure out how to correlate the
          messages. </para>
      </speakernotes>
    </foil>
  </foilgroup>
  <foilgroup>
    <title>Securing Web Applications</title>
    <subtitle>Important threats and how to guard against them</subtitle>
    <foil>
      <title>OWASP Top Ten</title>
      <para>List of the top ten attacks, how they work, how to prevent them. We’ll concentrate on
        three important attacks: </para>
      <itemizedlist>
        <listitem>
          <para>SQL Injection </para>
        </listitem>
        <listitem>
          <para>Cross-Site Scripting (XSS) </para>
        </listitem>
        <listitem>
          <para>Cross-Site Request Forgery (CSRF)</para>
        </listitem>
      </itemizedlist>
    </foil>
    <foil>
      <title>SQL Injection</title>
      <mediaobject role="center">
        <alt>Little Bobby Drop Table</alt>
        <imageobject>
          <imagedata fileref="../images/xkcd327.png"/>
        </imageobject>
        <caption><para>http://xkcd.com/327/</para></caption>
      </mediaobject>
      <speakernotes>
        <para>Injection attacks, including SQL injection attacks. The attacker manages to send some
          data to the system that is malicious and the system acts on that data. Any part of the
          system can be attacked, so there are attacks using SQL queries, XPath or XQuery, or plain
          XML. The injection can add unwanted data to a database, including giving the attacker
          administrator privileges on your system. One way in which this can occur is when the
          server trusts information from a form, or a query string on a URL. The attacker simply
          adds some data to the form that changes the meaning of the query. E.g., the standard SQL
          injection attack: </para>
      </speakernotes>
    </foil>
    <foil>
      <title>Example code</title>
      <programlisting role="other" language="SQL">
<phrase role="kw">String</phrase> <varname>query</varname> = "<phrase role="kw">SELECT</phrase> * <phrase role="kw">FROM</phrase> <varname>accounts</varname> <phrase role="kw">WHERE</phrase> <varname>custID</varname> = 
'" + request.getParameter("id") +"'";
</programlisting>
      <para>The attacker changes the query URL to <code>http://example.com/app/accountView?id=' or
          '1'='1</code> which leads to the complete query being</para>
      <programlisting role="other" language="SQL">
<phrase role="kw">SELECT</phrase> * <phrase role="kw">FROM</phrase> <varname>accounts</varname> <phrase role="kw">WHERE</phrase> <varname>custID ='' or  '1'='1'</varname>
</programlisting>
      <para><code>'1'='1'</code> is always true, so the query returns the entire account
        list.</para>
    </foil>
    <foil>
      <title>Preventing SQL Injection Attacks</title>
      <itemizedlist>
        <listitem>
          <para>Stop writing dynamic queries and/or </para>
        </listitem>
        <listitem>
          <para>Ensure malicious user-supplied input can’t do anything <itemizedlist>
              <listitem>
                <para>use prepared statements </para>
              </listitem>
              <listitem>
                <para>use stored procedures </para>
              </listitem>
              <listitem>
                <para>escape user-supplied input </para>
              </listitem>
              <listitem>
                <para>principle of least privilege </para>
              </listitem>
              <listitem>
                <para>principle of white list input validation </para>
              </listitem>
            </itemizedlist>
          </para>
        </listitem>
      </itemizedlist>
      <para>Check the OWASP SQL Injection Cheat Sheet for more details</para>
      <speakernotes>
        <para>There are variations on this theme of course, but they all involve data that shouldn’t
          be trusted but is. There’s a scary web site at
          http://www.unixwiz.net/techtips/sql-injection.html that shows just how easy it is to gain
          access to some databases where input hasn’t been properly sanitized. There are a number of
          methods to try to stop SQL injection attacks. The safest method for all injection attacks
          is to be paranoid and only allow the data you need to. </para>
        <para>Prepared statements (also called parameterized queries) force the developer to first
          define all the SQL code, and then pass in each parameter to the query later. This coding
          style allows the database to distinguish between code and data, regardless of what user
          input is supplied. In the example previously, the system would look for a customer id that
          is literally “' or '1'='1” which won’t find anything. </para>
        <para>Stored procedures are similar, but the code is stored in the database. </para>
        <para>For escaping user input, you take advantage of the fact that each DBMS supports one or
          more character escaping schemes specific to certain kinds of queries. If you then escape
          all user supplied input using the proper escaping scheme for the database you are using,
          the DBMS will not confuse that input with SQL code written by the developer, thus avoiding
          any possible SQL injection vulnerabilities. </para>
        <para>Least privilege is basic security: minimise what the account doing the work is allowed
          to do. If your app only looks at data in the database, it doesn’t need to be allowed to
          add data, so make sure the account it runs under doesn’t have that privilege. </para>
        <para>White-list is similarly a basic security principle: only allow what you have to. If
          your app doesn’t need to allow certain characters (e.g., for user names, you may choose to
          not allow semi-colons in the name), don’t. n particular, screening out non-printing
          characters is a good step for most text fields. </para>
      </speakernotes>
    </foil>
    <foil>
      <title>XSS attacks</title>
      <para>Cross-site scripting (aka CSS) </para>
      <itemizedlist>
        <listitem>
          <para>Malicious script tricks user’s browser into thinking it comes from a trusted source
          </para>
        </listitem>
        <listitem>
          <para>Can access cookies, security tokens, etc, as fully trusted </para>
        </listitem>
      </itemizedlist>
      <para>Example: </para>
      <itemizedlist>
        <listitem>
          <para>comment site allows full HTML </para>
        </listitem>
        <listitem>
          <para>attacking comment includes javascript that runs when victim loads the page </para>
        </listitem>
        <listitem>
          <para>comment is on same site, so can access cookies etc defined by that site, including,
            e.g., login info </para>
        </listitem>
      </itemizedlist>
      <speakernotes>
        <para>OWASP calls this the most prevalent web application security flaw. It’s another case
          where the application wrongly trusts some attacker-supplied data, and the cure, as for the
          SQL injection attack we just talked about, is to make sure any user-supplied data is
          validated or appropriately escaped, in case it’s really a malicious script. The web pages
          today aren’t just static HTML. They are more dynamic, including scripts that change the
          page in the user’s browser, without the server being involved. That means that a malicious
          script that can trick the browser into thinking it came from the server originally will be
          trusted, and can then change any part of the page, hijack the unsuspecting user’s browser,
          or redirect the victim to a phishing or spoof site. Because the victim’s browser thinks
          the malicious script comes from a trusted source, it lets it do anything - access cookies
          or security tokens, for example. It’s called cross-site scripting because the original
          versions attacked the target site from a different attack site. </para>
        <para>The basic idea is best explained using a comment system. Let’s say the attacker goes
          to a web site that allows comments with HTML. The attacker carefully crafts a comment to
          include some javascript that runs when the victim loads the page in their browser. Since
          the victim is on the trusted site, the attack code can steal cookies or other information
          that is usually sand-boxed, including, for example, login information if the victim is
          logged in at the trusted site. </para>
      </speakernotes>
    </foil>
    <foil>
      <title>Variations of XSS</title>
      <itemizedlist>
        <listitem>
          <para>Attacker crafts query URI and cons the victim into clicking on it from email </para>
        </listitem>
        <listitem>
          <para>Attacker (mis)uses some HTML element <itemizedlist>
              <listitem>
                <para>script element, to load external script </para>
              </listitem>
              <listitem>
                <para>add onload attribute to body element </para>
              </listitem>
              <listitem>
                <para>put a script in the src attribute of an img element </para>
              </listitem>
              <listitem>
                <para>put script in rel=”stylesheet” attribute of link element </para>
              </listitem>
              <listitem>
                <para>put script in background attribute of table element</para>
              </listitem>
            </itemizedlist></para>
        </listitem>
      </itemizedlist>
      <speakernotes>
        <para>Another example is when the attacker crafts a query URL and cons the victim into
          clicking on it (e.g., from an attack site or email); the victim goes to the trusted site
          and doesn’t notice the odd characters after the “?” in the URL – which carry sufficient
          code to steal the same information. </para>
        <para>Variations of this attack exist using lots of different HTML elements. The best known
          is the script element (as an external script that’s loaded, for example, or the comment
          form changes above), but attacks can also work by changing the body element to include an
          onload event or background attribute, putting a script in the src attribute of an image
          element, putting a script in the rel = “stylesheet” attribute of a link element instead of
          a stylesheet, or putting a script in the background attribute of a table element. </para>
      </speakernotes>
    </foil>
    <foil>
      <title>Preventing XSS attacks</title>
      <para>Multi-layer prevention is best </para>
      <itemizedlist>
        <listitem>
          <para>only allow characters that make sense in the context <itemizedlist>
              <listitem>
                <para>e.g., don’t allow input into a script </para>
              </listitem>
              <listitem>
                <para>don’t allow non-printable characters in name fields </para>
              </listitem>
            </itemizedlist></para>
        </listitem>
        <listitem>
          <para>ensure input data can’t change the HTML DOM tree </para>
        </listitem>
        <listitem>
          <para>escape all HTML/XML significant characters with entities, e.g., &lt; </para>
        </listitem>
        <listitem>
          <para>consider escaping all “special” characters with the right character or numeric
            entity (ASCII code under 256) </para>
        </listitem>
        <listitem>
          <para>escape JavaScript, CSS, and URIs appropriately </para>
        </listitem>
      </itemizedlist>
      <para>Check the OWASP XSS Prevention Cheat Sheet</para>
      <speakernotes>
        <para>Injecting UP: The most common way is to close the current context and start a new code
          context. For example, this is what you do when you close an HTML attribute with a "> and
          start a new &lt;script> tag. This attack closes the original context (going up in the
          hierarchy) and then starts a new tag that will allow script code to execute. Remember that
          you may be able to skip many layers up in the hierarchy when trying to break out of your
          current context. For example, a &lt;/script> tag may be able to terminate a script block
          even if it is injected inside a quoted string inside a method call inside the script. This
          happens because the HTML parser runs before the JavaScript parser. </para>
        <para>Injecting DOWN: The less common way to perform XSS injection is to introduce a code
          subcontext without closing the current context. For example, if the attacker is able to
          change &lt;img src="...UNTRUSTED DATA HERE..." /&gt; into &lt;img
          src="javascript:alert(document.cookie)" /&gt; they do not have to break out of the HTML
          attribute context. Instead, they introduce a subcontext that allows scripting within the
          src attribute (in this case a javascript url). Another example is the expression()
          functionality in CSS properties. Even though you may not be able to escape a quoted CSS
          property to inject up, you may be able to introduce something like
          xss:expression(document.write(document.cookie)) without ever leaving the current context.
        </para>
      </speakernotes>
    </foil>
    <foil>
      <title>CSRF Attacks</title>
      <para>Cross-Site Request Forgery </para>
      <itemizedlist>
        <listitem>
          <para>victim is logged in somewhere </para>
        </listitem>
        <listitem>
          <para>attacker convinces victim to run a script </para>
        </listitem>
        <listitem>
          <para>script action is carried out, since victim is logged in </para>
        </listitem>
      </itemizedlist>
      <para>Prevention: complicated </para>
      <para>Good measures to not become a victim </para>
      <itemizedlist>
        <listitem>
          <para>log out of your bank site when you’re finished </para>
        </listitem>
        <listitem>
          <para>don’t automatically save usernames and passwords to sensitive sites </para>
        </listitem>
      </itemizedlist>
      <speakernotes>
        <para>This one is also wide-spread, perhaps not quite as nasty as the other two, but worth
          knowing about. It’s an exploit where the server carries out some action on behalf of the
          victim because it trusts the victim, or, more to the point, trusts the victim’s browser.
          The victim is authenticated at a site and is then tricked into sending a request to the
          server to carry out the action. It’s also called session riding. As an example – the
          victim carried out some business at their bank, and the authentication is still valid.
          Let’s assume the authentication information is in a cookie. And the bank has a simple way
          to move money from one account to another, something like </para>
        <para>http://example.com/move?from=victim&amp;amount=1000&amp;to=attacker </para>
        <para>Then if the attacker can convince the victim to click on an appropriate link, or view
          an image where the source is a script, the action will be carried out because the victim
          is still logged in and still has a valid cookie. There are defences against this attack,
          but it’s more difficult than for the others, so it’s still a good idea to sign out of your
          bank account or other high-security web site before browsing random forums or unknown web
          sites that could be affected. And, to top it off, XSS is often used to introduce a CSRF
          attack.  Rhetorical question: are you paranoid enough yet? Let’s fix one of these issues
          in our sample application. </para>
        <para>Rhetorical question: are you paranoid enough yet? Let’s fix one of these issues in our
          sample application.</para>
      </speakernotes>
    </foil>
    <foil>
      <title>Exercise</title>
      <para>Identify and fix security issues in sample application</para>
    </foil>
    <foil>
      <title>CSRF prevention</title>
      <programlisting language="ruby"><![CDATA[
class AnnotatedShakespeare < Sinatra::Base
  use OmniAuth::Builder do
    provider :browser_id, :verify_url => '...'
  end
  use Rack::Protection::AuthenticityToken
  ...
  helpers do
    def csrf_token
      session[:csrf] ||= SecureRandom.hex
    end
  end
end
]]></programlisting>
      <para><code>lib/annotated_shakespeare.rb</code></para>
    </foil>
    <foil>
      <title>CSRF prevention</title>
      <programlisting language="html+erb"><![CDATA[
<form ... >
  <input name="authenticity_token" 
    value="<%= csrf_token %>" 
    type="hidden">
  <textarea name="comment[body]"></textarea>
  <p><input type="submit" value="Add comment"></p>
</form>
]]></programlisting>
      <para><code>views/show.erb</code></para>
    </foil>
    <foil>
      <title>CSRF prevention</title>
      <sidebar>
        <title>Oh Noes!</title>
      </sidebar>
    </foil>
    <foil>
      <title>CSRF prevention, take 2</title>
      <programlisting language="ruby"><![CDATA[
class OAAwareAuthenticityToken < 
      Rack::Protection::AuthenticityToken
  def accepts?(env)
    return true if safe?(env)
    return true if env['omniauth.auth']
    super(env)
  end
end

class AnnotatedShakespeare < Sinatra::Base
  use OmniAuth::Builder do
    provider :browser_id, :verify_url => '...'
  end
  use OAAwareAuthenticityToken
  ...
end
]]></programlisting>
      <para><code>lib/annotated_shakespeare.rb</code></para>
    </foil>
    <foil>
      <title>Resources</title>
      <simplelist>
        <member>http://www.moserware.com/2009/06/first-few-milliseconds-of-https.html</member>
        <member>http://www.codeproject.com/Articles/9378/SQL-Injection-Attacks-and-Some-Tips-on-How-to-Prev</member>
        <member>https://www.schneier.com/blog/archives/2012/03/the_security_of_5.html</member>
        <member>http://www.slideshare.net/johnwilander/application-security-for-rich-internet-applicationss-jfokus-2012</member>
        <member>https://code.google.com/p/webgoat/</member>
      </simplelist>
    </foil>
  </foilgroup>
</slides>
